{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/5-ways-to-benefit-from-typescript-in-react","result":{"data":{"markdownRemark":{"html":"<p>In the <a href=\"https://brightinventions.pl/blog/modern-way-getting-started-react-typescript/\">recent post</a> we discussed how we can start a new React project with TypeScript to benefit from all the goodies of type checks and eliminate the whole class of errors and typos from our codebase. Now let’s see how we can apply TypeScript-based type definitions into our React project to get most of it.</p>\n<p>To get started, as with every library we want to have the TypeScript support for, we need to grab the type definitions first. As usual, the way to do it is using the <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped\">DefinitelyTyped</a> project and run:</p>\n<pre><code class=\"language-bash\">npm install --save-dev @types/react @types/react-dom\n</code></pre>\n<h2>The basics – Components</h2>\n<p>The components in React are in most cases ES6 classes that extend React-provided <code>Component</code> class. TypeScript is adding two generic arguments to this base class definition – the first one defines what our props are and the second is for the local component’s state.</p>\n<pre><code class=\"language-typescript\">interface HelloProps {\n    greeting: string\n}\n\ninterface HelloState {\n    wasDisplayed: boolean\n}\n\nclass HelloWorldComponent extends React.Component&#x3C;HelloProps, HelloState> {}\n</code></pre>\n<p>By adding these two definitions we’re not only adding a code completion capability to our component. Here I denoted I expect a <code>greeting</code> property and marked it as non-optional (no <code>?</code> sign before a colon and no union type that allows <code>undefined</code> to sneak through). The compiler now successfully prevents us from using this component without the proper <code>greeting</code> property passed in.</p>\n<p><img src=\"/images/react-ts/props-undefined.png\" alt=\"Props completeness is enforced\"></p>\n<h3>Props &#x26; state (im)mutability</h3>\n<p>But there’s more. In React, both props and state are intended to be immutable. Props are for getting the data into the component only and state is to be modified via the specialized <code>setState</code> method. Thanks to both props and state defined as being of type <code>Readonly&#x3C;></code>, we are protected from accidentally mutating it:</p>\n<p><img src=\"/images/react-ts/props-immutable.png\" alt=\"Props immutability is enforced\">￼</p>\n<p>As well as we’re not allowed to monkey-patch it, that is to add new properties there:</p>\n<p><img src=\"/images/react-ts/props-frozen.png\" alt=\"Props are frozen\">￼</p>\n<p>Having said that, we must be aware that <code>Readonly&#x3C;></code> is not deep (recursive) – it only protects us from mutating the root level of the object, nothing protects its children objects:</p>\n<pre><code class=\"language-typescript\">interface State {\n    inner: {stuff: string}\n}\n\n// this is still possible\nthis.state.inner.stuff = \"inner’s properties are still mutable\"\n</code></pre>\n<p>Until React's typings implement the proper support for deep Readonly (<a href=\"https://github.com/Microsoft/TypeScript/pull/21316\">which is possible starting from TypeScript 2.8</a>), the best we can (and should) do is to ensure on our own that all the properties of both props and state of our components are also marked as <code>Readonly&#x3C;></code> (as well as its inner properties, ad infinitum):</p>\n<pre><code class=\"language-typescript\">interface State {\n    inner: Readonly&#x3C;{stuff: string}>\n}\n\n// now we’re safe again\nthis.state.inner.stuff = \"this does not compile anymore\"\n</code></pre>\n<h3><code>setState</code> correctness</h3>\n<p>Another class of errors we’re automatically protected from is when we call <code>setState</code> with an invalid object. The first parameter of this function is defined with a rather cryptic type declaration:</p>\n<pre><code class=\"language-typescript\">state: ((prevState: Readonly&#x3C;S>, props: P) => (Pick&#x3C;S, K> | S | null)) | (Pick&#x3C;S, K> | S | null),\n</code></pre>\n<p>But when reading piece by piece it tells us we either need to pass a function that returns <code>Pick&#x3C;S, K> | S | null</code> or return it directly. And that <code>Pick&#x3C;S, K> | S | null</code> thing is – reading backwards – either <code>null</code>, full state object itself (<code>S</code>) or an object with a subset of the state’s keys (<a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types\"><code>Pick&#x3C;S, K></code></a>). To cut the long story short, we are unable to pass the new state value object that doesn’t match our state definition. Here is the error that the TypeScript compiler gives us instead:</p>\n<p><img src=\"/images/react-ts/state-correctness.png\" alt=\"State correctness is enforced\">￼￼</p>\n<h2>Stateless components</h2>\n<p>Seasoned React developers are probably familiar with the simplest form of components available – <a href=\"https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc\">stateless functional components</a>. These are defined as pure functions that receive the props and return an JSX element. As simple as that, from the typing perspective it is usually  sufficient to treat it like any other function – specifying types of its parameters and optionally the return type:</p>\n<pre><code class=\"language-typescript\">interface InputProps {\n    value: any\n    onChanged: () => void\n}\n\nfunction Input(props: InputProps) {\n    return &#x3C;input type=\"text\" onChange={props.onChanged} value={props.value}/>\n}\n</code></pre>\n<p>We can have a problem here, though, if we want to specify <code>propTypes</code> or <code>defaultProps</code> for our stateless component. TypeScript will complain as plain functions do not have that kind of properties defined:</p>\n<p><img src=\"/images/react-ts/propTypes.png\" alt=\"PropTypes cannot be added to plain function\">￼￼</p>\n<p>We can solve it by declaring our component in a slightly different manner:</p>\n<pre><code class=\"language-typescript\">const Input: React.StatelessComponent&#x3C;InputProps> = function (props) {\n    return &#x3C;input type=\"text\" onChange={props.onChanged} value={props.value}/>\n}\n\nInput.propTypes = {\n    value: PropTypes.any.isRequired\n}\n</code></pre>\n<p>But let’s stop and think for a moment what we’re trying to achieve here. Doesn’t TypeScript give us a similar level of type safety with much more convenience already? I find <a href=\"https://dbushell.com/2017/04/19/typescript-instead-of-react-proptypes/\">using PropTypes not needed anymore</a> at all.</p>\n<h2>Events</h2>\n<p>Our next stop in the React world that might make use of stronger typing is around Events system. We take care of events every time we want our component to react to user actions. Let’s see our simplistic <code>Input</code> component once again:</p>\n<pre><code class=\"language-typescript\">interface InputProps {\n    value: any\n    onChanged: () => void\n}\n\nfunction Input(props: InputProps) {\n    return &#x3C;input type=\"text\" onChange={props.onChanged} value={props.value}/>\n}\n</code></pre>\n<p>The <code>onChange</code> property, as every event handler, takes an event object as the only parameter. Let’s express it in our <code>InputProps</code> interface definition. <code>Event</code> is a name defined by the HTML spec itself, so let’s first try using it here:</p>\n<pre><code class=\"language-typescript\">onChanged: (event: Event) => void\n</code></pre>\n<p>Unfortunately, this seems to be not the event we should care about:</p>\n<p><img src=\"/images/react-ts/event-native.png\" alt=\"React does not use native HTML events\">￼￼\n￼\nThis rather verbose error gives us the expected type of an event, above anything else – see its last line. The event object passed by React is actually typed as <code>ChangeEvent&#x3C;HTMLInputElement></code> and this type seems not to extend the HTML built-in <code>Event</code> type. This is intentional because React doesn’t use the HTML events directly – it uses <a href=\"https://reactjs.org/docs/events.html\">Synthetic Events</a> wrappers instead.</p>\n<p>When we change our <code>Event</code> type definition to the synthetic event type determined by both event type and element type, we are fine:</p>\n<pre><code class=\"language-typescript\">onChanged: (event: React.ChangeEvent&#x3C;HTMLInputElement>) => void\n</code></pre>\n<p>This gives us the best possible confidence level for what we can expect to get as an argument. It horribly reduces the flexibility, though. We can no longer have the same change handler for events fired on multiple types of HTML Elements (for example, <code>&#x3C;input></code> and <code>&#x3C;select></code>:</p>\n<p><img src=\"/images/react-ts/event-incompatible.png\" alt=\"Events on different HTML elements are not compatible\">￼￼￼</p>\n<p>We got an error indicating near the end that <code>HTMLSelectElement</code> is not assignable to <code>HTMLInputElement</code>. Well, it is not, indeed, and our handler was defined to accept the former only and we’re unable to reuse that handler directly. A similar problem occurs if we want to attach the same handler to the events of multiple types (i.e. change, click, mouse interaction etc.) – <code>ChangeEvent&#x3C;T></code> and <code>MouseEvent&#x3C;T></code> are not compatible.</p>\n<p>Fortunately, TypeScript provides a decent set of type system features that might help us here. First, we can use the common ancestor event type instead of the specific <code>ChangeEvent</code> – <code>SyntheticEvent</code> is a good fit. The generic parameter that describes the type of element we handle our event on is more troublesome. We might try with a <code>HTMLElement</code> base type and in some cases it will suffice. But my usual case for the generic event handling is to handle multiple form elements and access its value attributes. Apparently there is no common type for all form elements that defines the <code>value</code> attribute. We have at least two ways to work around it. First, the mercy of <a href=\"http://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types\">union types</a> where we can specify an alternative of types we want to handle and its common attributes will be freely available: </p>\n<pre><code class=\"language-typescript\">onGenericEvent: (event: React.SyntheticEvent&#x3C;HTMLSelectElement | HTMLInputElement>) => void\n</code></pre>\n<p>This is nice and explicit, although it doesn’t scale well if we want to handle more than few elements at once. The second solution uses the <a href=\"https://basarat.gitbooks.io/typescript/docs/types/type-compatibility.html#structural\">structural type compatibility</a> – yet another extremely neat TypeScript’s type system functionality that allows us to define and compare types by its structure only. If our case is to read a value of <code>value</code> attribute of the handled element’s only, we might state it explicitly in our handler type definition:</p>\n<pre><code class=\"language-typescript\">onGenericEvent: (event: React.SyntheticEvent&#x3C;{value: string}>) => void\n</code></pre>\n<p>The TypeScript’s type system allows us to choose which level of specificity vs. flexibility is appropriate in our case.</p>\n<h3>Ugly case of generic <code>setState</code></h3>\n<p>It’s not all flowers and roses, unfortunately. My typical scenario for form handling in React is to directly set the component’s state properties from the form elements values on their change events:</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={event => this.setState({firstName: event.currentTarget.value})} />\n</code></pre>\n<p>We might try to keep it generic by eliminating the duplication of the input’s name and assuming the name matches the key we want to set within the state and use <a href=\"http://www.benmvp.com/learning-es6-enhanced-object-literals/\">enhanced object literals</a> from ES6 specification (the thing with dynamic property names specified in square brackets):</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={event => this.setState({[event.currentTarget.name]: event.currentTarget.value})} />\n</code></pre>\n<p>As we have previously seen, TypeScript ensures the keys of the object we pass to <code>setState</code> match the actual properties of our component’s state. But here, TypeScript compiler (as of 2.6.1 at least) is not that smart to figure out what the actual value of event’s target <code>name</code> attribute would be, even though it can only be equal to <code>firstName</code> in this case. For TypeScript it is a general string and this is too wide to be considered valid for our <code>setState</code> call, unfortunately:</p>\n<p><img src=\"/images/react-ts/event-generic.png\" alt=\"TypeScript is unable to specify down setState parameter types\">￼￼￼</p>\n<p>We may work around it with type cast to inform TypeScript compiler what is the range of values we might potentially expect from <code>event.currentTarget.name</code> (assuming <code>State</code> describes the state of our component). The <code>keyof State</code> construct informs the compiler that the strings there may only be those that are defined by <code>State</code> interface structure:</p>\n<pre><code>&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={e => this.setState({[e.currentTarget.name as keyof State]: e.currentTarget.value})}/>\n</code></pre>\n<p>Or, alternatively, if we want to avoid type casts, we may satisfy the <code>setState</code> call by ensuring the full state is always passed (including the expected modifications). It is actually taking advantage of a bit separate React’s feature than the partial state update, but should behave the same way:</p>\n<pre><code class=\"language-html\">&#x3C;input type=\"text\" name=\"firstName\" \n       onChange={e => this.setState({...this.state, [e.currentTarget.name]: e.currentTarget.value})}/>\n</code></pre>\n<p>Note I’m using not-yet-standard <a href=\"https://github.com/tc39/proposal-object-rest-spread\">object spread operator</a> here. It creates a copy of <code>this.state</code> and replaces (or adds) a single property to this copy – in this case it will set <code>firstName</code> property to the value of input’s <code>value</code> attribute, reflecting what the user has typed into the box.</p>\n<h2>What’s more?</h2>\n<p>As you might have already noticed, all the HTML elements have its attributes mapped into <code>HTML*Element</code> types we can benefit from whenever we’re operating on the elements. Similarly, a good subset of the CSS properties are mapped into the <code>CSSProperties</code> interface that defines all the predefined values the particular CSS property might use. This might be useful to use if we use any form of the <a href=\"https://reactjs.org/docs/dom-elements.html#style\">inline styles</a> in our components. It would provide a proper code completion and in some cases ensure the validation of our CSS definitions:\n￼\n<img src=\"/images/react-ts/css-properties.png\" alt=\"TypeScript helps with CSS validity\">￼￼￼</p>\n<p>I hope you already feel that TypeScript can offer a lot of benefits to your React codebase, even though we’ve just touched the iceberg tip. In the <a href=\"https://brightinventions.pl/blog/using-typescript-with-redux/\">next post</a> we'll add Redux into the mix and see how TypeScript can help us there, too.</p>","excerpt":"In the recent post we discussed how we can start a new React project with TypeScript to benefit from all the goodies of type checks and…","frontmatter":{"slug":null,"title":"5 (or more) ways to benefit from TypeScript in React projects","description":null,"author":"adam","tags":["React","TypeScript","web"],"date":"2018-04-11T22:00:00.000Z","image":"/images/react-ts/props-immutable.png"},"timeToRead":9,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-04-12-5-ways-to-benefit-from-typescript-in-react.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-04-12-5-ways-to-benefit-from-typescript-in-react.md"}}}