{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/develop-your-own-cryptocurrency-with-substrate-2","result":{"data":{"markdownRemark":{"html":"<p>This is the second part of a series where we are implementing an ERC20 token with a Substrate node and accessing it from a NestJS application. The first part is available <a href=\"https://brightinventions.pl/blog/erc20-substrate-nest-example/\">here</a>. In this part, we will have a glimpse of the implementation of the ERC20 token using Substrate Runtime. We will also access it from a NestJS app.</p>\n<p>You can access the <a href=\"https://github.com/bright/substrate-erc20-nestjs/tree/part2\">working project on GitHub</a></p>\n<h2>Before we start</h2>\n<p>Before we start, build the node, purge the chain, and run it in development mode.</p>\n<pre><code class=\"language-shell\">cargo build --release\n./target/release/node-template purge-chain --dev\n./target/release/node-template --dev\n</code></pre>\n<p>We will be using the smart contract from the previous part. You will probably need to <em>forget</em> the old smart contract instance and the wasm file in the Polkadot JS Apps (it is no longer available on-chain thus still visible in the UI). Go to <em>Developer</em> -> <em>Contracts</em> page. In the <em>Contracts</em> tab use the bin button next to the contract instance to forget the contract.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image8.png\"></p>\n<p>In the <em>Code</em> tab use the bin button next to the code hash to forget the code.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image9.png\"></p>\n<p>Now you can upload the code again and deploy the smart contract. Don't forget to update the smart contract address in the NestJS app if needed.</p>\n<h2>ERC20 token in Runtime</h2>\n<p>We will go through the code of the substrate runtime pallet available in <a href=\"https://github.com/bright/substrate-erc20-nestjs/tree/part2/substrate-node-template/pallets/erc20\">this posts repo</a>. We will explore the storage items, dispatchable functions, events, and errors. In parts, the code is based on the Substrate Runtime cookbook <a href=\"https://substrate.dev/recipes/basic-token.html\">basic token implementation</a>. If you want to get a deeper understanding of developing your own runtime modules I recommend starting off with the <a href=\"https://substrate.dev/docs/en/tutorials/build-a-dapp/\">Build a PoE Decentralized Application</a>. <a href=\"https://www.shawntabrizi.com/substrate-collectables-workshop/#/\">Substrate Collectables Workshop</a> is also a great tutorial. Even though it bases on an older version of the Substrate Node Template, it gives a good understanding of Rust and Substrate modules principals.</p>\n<p>The code we are going to focus on is placed in an <code>erc20</code> pallet in the <code>lib.rs</code> <a href=\"https://github.com/bright/substrate-erc20-nestjs/blob/part2/substrate-node-template/pallets/erc20/src/lib.rs\">file</a>. The pallet is called <code>erc20</code> and this is how we can access it from Polkadot JS API.</p>\n<h3>Storage items</h3>\n<p>Storage items are our boxes for data. The storage items are placed inside the <code>decl_storage</code> macro (if you see an exclamation mark in Rust, you are most likely using a <a href=\"https://doc.rust-lang.org/1.7.0/book/macros.html\">macro</a>).</p>\n<pre><code class=\"language-rust\">decl_storage! {\n    trait Store for Module&#x3C;T: Trait> as Erc20Module {\n      pub BalanceOf get(fn balance_of): map hasher(blake2_128_concat) T::AccountId => u64;\n          pub TotalSupply get(fn total_supply): u64 = 0;\n          Init get(fn is_init): bool;\n          pub Allowance get(fn allowance): map hasher(blake2_128_concat) (T::AccountId, T::AccountId) => u64;\n    }\n}\n</code></pre>\n<p>Let's break down the <code>BalanceOf</code> item declaration.</p>\n<ul>\n<li><code>pub</code> - the public/private modifiers only define whether or not <strong>other modules can access the items</strong>. You can read any storage item from the chain regardless of the scope defined here.</li>\n<li><code>BalanceOf</code> - the name of the item. It is also the name of a getter function, that will be exposed to the world (i.e. through the Polkadot JS API).</li>\n<li><code>get(fn balance_of)</code> - this is a getter function you, as a <strong>developer</strong>, can use inside this module. You can now access the value in two ways: the default one <code>&#x3C;BalanceOf&#x3C;T>>::get(accountId)</code> and with the getter function <code>Self::balance_of(accountId)</code>.</li>\n<li><code>map hasher(blake2_128_concat) T::AccountId => u64</code> - a storage item can be a simple value or some more complex structure like for example a map. We can also assign some initial value as in the <code>TotalSupply</code> item definition: <code>u64 = 0</code>.</li>\n</ul>\n<p>With the declared storage items we will be able to query the module for the total supply of the token (<code>TotalSupply</code>), a balance of any account (<code>BalanceOf</code>), and allowance of a pair of accounts (<code>Allowance</code>). The <code>Init</code> item will tell us if the token is already initialized. </p>\n<p>You can already play with your pallet with <a href=\"https://polkadot.js.org/apps\">Polkadot JS Apps</a>. Go to the <em>Developer</em> -> <em>Chain State</em> page, <em>Storage</em> tab. Select <code>erc20</code> pallet in the left dropdown. In the right dropdown, you can now see the getter functions. As we have not initialized the token yet, you will get <code>false</code> as a result of <code>init()</code> and zeros for the other functions.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image7.png\"></p>\n<h3>Functions</h3>\n<p>All the dispatchable functions are placed inside the <code>decl_module</code> macro. Let's take a look at the shortcut of it.</p>\n<pre><code class=\"language-rust\">decl_module! {\n  pub struct Module&#x3C;T: Trait> for enum Call where origin: T::Origin {\n    pub fn init(origin, total_supply: u64) {}\n    pub fn transfer(origin, to: T::AccountId, value: u64) {}\n    pub fn approve(origin, spender: T::AccountId, value: u64) {}\n    pub fn transfer_from(origin, owner: T::AccountId, to: T::AccountId, value: u64) {}\n  }\n}\n</code></pre>\n<p>As you can see, we have all the functions known from the smart contract implementation: <code>transfer</code> for transferring owned tokens, <code>approve</code> to allow someone to transfer our tokens, and <code>transfer_from</code> to transfer tokens on behalf.</p>\n<p>There is also an additional <code>init</code> function, which we will cover in a moment.</p>\n<h3>Events</h3>\n<p>When we submit a transaction, it gets included in a block, which is then approved to be a part of the chain. Once it is approved in the chain, the status is finalized. A finalized transaction does not however mean that the business function was successful. To reflect the actual state of the business logic we can use events and errors. Events are declared in the <code>decl_event</code> macro. You can use the documentation comments to describe the event. We have three events for each of the features: initialization of the token, transferring tokens and approving.</p>\n<pre><code class=\"language-rust\">decl_event! {\n  pub enum Event&#x3C;T> where AccountId = &#x3C;T as system::Trait>::AccountId {\n    /// Token was initialized by user\n    Initialized(AccountId),\n    /// Tokens successfully transferred between users\n    Transfer(AccountId, AccountId, u64), // (from, to, value)\n    /// Allowance successfully created\n    Approval(AccountId, AccountId, u64), // (from, to, value)\n  }\n}\n</code></pre>\n<h3>Errors</h3>\n<p>As we said earlier, a transaction should be finalized thus failed. As, by design, we are not allowed to panic in a runtime function, we use errors to reflect the failure in a gentle manner. Errors are defined in the <code>decl_error</code> macro. Again, you can use the documentation comments to describe the events.</p>\n<pre><code class=\"language-rust\">decl_error! {\n  pub enum Error for Module&#x3C;T: Trait> {\n    /// Attempted to initialize the token after it had already been initialized.\n    AlreadyInitialized,\n    /// Attempted to transfer more funds than were available\n    InsufficientFunds,\n    /// Attempted to transfer more funds than approved\n    InsufficientApprovedFunds,\n  }\n}\n</code></pre>\n<h2>Token initialization</h2>\n<p>Let's take a look at the <code>init</code> function.</p>\n<pre><code class=\"language-rust\">pub fn init(origin, total_supply: u64) {\n  let sender = ensure_signed(origin)?;\n  ensure!(!Self::is_init(), &#x3C;Error&#x3C;T>>::AlreadyInitialized);\n\n  TotalSupply::put(total_supply);\n  &#x3C;BalanceOf&#x3C;T>>::insert(&#x26;sender, total_supply);\n\n  Init::put(true);\n\n  Self::deposit_event(RawEvent::Initialized(sender));\n}\n</code></pre>\n<p>The purpose of this function is to create a token with some initial supply and give all the units to the user who has signed the transaction. This is to be done once only. The first thing to do is to obtain the sender. There is the <code>origin</code> parameter, which is always the first parameter of a dispatchable function of a pallet. Amongst other data related to the transaction, it contains the sender.</p>\n<p>In the second line of the function, we check if the token was already initialized and emit an error if so. </p>\n<p>If the token was not initialized yet, we put the total supply value in the corresponding storage value. Next, we set the balance of the sender to the total supply value. The last step is to set the <code>Init</code> storage value to true so that we know the token has already been initialized.</p>\n<p>In the very last line of the <code>init</code> function, we emit an <code>Initialized</code> event with the sender account.</p>\n<p>Let's now initialize our token. We will use <a href=\"https://polkadot.js.org/apps\">Polkadot JS Apps</a> to call the function. Go to <em>Developer</em> -> <em>Extrinsics</em> page. Choose an account to create a token with. Choose the <code>erc20</code> and <code>init(tital_supply)</code> extrinsic to submit. Fill in the <code>total_supply</code> value.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image1.png\"></p>\n<p>Sign and submit the transaction. You can see some events showing up in the upper right corner. One of them is the <code>Initialized</code> event.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image2.png\"></p>\n<p>We can also view the details of the event in the <em>Network</em> -> <em>Explorer</em> page.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image3.png\"></p>\n<p>In the <em>recent events</em> block you can see the <code>erc20.Initialized</code> event. Just below the name, you can see the description from the comments. When you expand it, you can see the sender account. On the right side of the event, you can see the block number and the extrinsic number, here it is <code>4-1</code>. You can click on it and explore the block.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image4.png\"></p>\n<p>We can now try to initialize the token once again. As we were expecting, an <code>AlreadyInitialized</code> error showed up.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image5.png\"></p>\n<p>We can also view the details of the error in the <em>Network</em> -> <em>Explorer</em> page. It will not however show up in the recent events table, so you need to check the last few blocks manually to find the one with the error.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image6.png\"></p>\n<p>You can again see the <code>type</code> of the error as the <code>AlreadyInitialized</code> we have declared in the code. The <code>details</code> field is a description from the comment.</p>\n<p>You can now check the values of <code>init</code> and <code>totalSupply</code> again in the <em>Chain state</em> page.</p>\n<h2>Polkadot JS API</h2>\n<p>Let's now switch to our backend app and try to call some runtime functions. We will start off from where we have finished the last part. We have a service for calling smart contract's functions and two controllers: for balances and approvals. We will create another service and switch between the two services in the controllers.</p>\n<p>First of all, we will create an interface for an ERC20 service which declares all the functions we need. We will also add a sender to each function, which creates a blockchain transaction (<code>transfer</code>, <code>approve</code>, and <code>transferFrom</code>). This will let us choose an account to send and sign a transaction with.</p>\n<pre><code class=\"language-typescript\">// src/erc20.interface.ts\n\nexport interface Erc20 {\n  totalSupply();\n  balanceOf(who: string);\n  transfer(sender: string, to: string, value: number);\n  allowance(owner: string, spender: string);\n  approve(sender: string, spender: string, value: number);\n  transferFrom(sender: string, from: string, to: string, value: number);\n}\n</code></pre>\n<p>Create a <code>PolkadotApiService</code> which will provide a connection to the Polkadot API. Move the logic from <code>onModuleInit</code> function from <code>ContractService</code> to the <code>onModuleInit</code> function of the new service. We will also add a keyring pair for each of the predefined accounts to be able to sign the transactions with it.</p>\n<pre><code class=\"language-typescript\">// src/polkadot-api.service.ts\n\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ApiPromise, Keyring, WsProvider } from '@polkadot/api';\nimport { Abi, PromiseContract } from '@polkadot/api-contract';\nimport { KeyringPair } from '@polkadot/keyring/types';\nimport metadata from \"./metadata.json\";\n\nconst SUBSTRATE_URL = 'ws://127.0.0.1:9944'\nexport const ERC20 = '5DhP1rd5AEZCeZY77Zttbt293rX6tX4QnqEajEMd5i1QKsnB'\n\n// accounts list to easily intercact with the API\nexport const ACCOUNTS = {\n  ALICE: {\n    address: '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',\n    pair: undefined,\n  },\n  BOB:  {\n    address: '5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty',\n    pair: undefined,\n  },\n  CHARLIE:  {\n    address: '5FLSigC9HGRKVhB9FiEo4Y3koPsNmBmLJbpXg2mp1hXcS59Y',\n    pair: undefined,\n  },\n  DAVE:  {\n    address: '5DAAnrj7VHTznn2AWBemMuyBwZWs6FNFjdyVXUeYum3PTXFy',\n    pair: undefined,\n  },\n  EVE:  {\n    address: '5HGjWAeFDfFCWPsjFQdVV2Msvz2XtMktvgocEZcCj68kUMaw',\n    pair: undefined,\n  },\n}\n\n@Injectable()\nexport class PolkadotApiService implements OnModuleInit {\n  api: ApiPromise;\n  abi: Abi;\n  apiContract: PromiseContract;\n\n  async onModuleInit() {\n    Logger.log('Connecting to substrate chain...');\n    const wsProvider = new WsProvider(SUBSTRATE_URL);\n    this.api = await ApiPromise.create({\n      provider: wsProvider,\n      types: {\n        \"Address\": \"AccountId\",\n        \"LookupSource\": \"AccountId\"\n      }\n    });\n\n    const abiJSONobj = (&#x3C;any>metadata);\n    this.abi = new Abi(this.api.registry, abiJSONobj);\n    this.apiContract = new PromiseContract(this.api, this.abi, ERC20);\n\n    await this.api.isReady;\n\n    const keyring = new Keyring({ type: 'sr25519' });\n    ACCOUNTS.ALICE.pair =  keyring.addFromUri('//Alice', { name: 'Alice default' });\n    ACCOUNTS.BOB.pair =  keyring.addFromUri('//Bob', { name: 'Bob default' });\n    ACCOUNTS.CHARLIE.pair =  keyring.addFromUri('//Charlie', { name: 'Charlie default' });\n    ACCOUNTS.DAVE.pair =  keyring.addFromUri('//Dave', { name: 'Dave default' });\n    ACCOUNTS.EVE.pair =  keyring.addFromUri('//Eve', { name: 'Eve default' });\n  }\n}\n</code></pre>\n<p>Register the new service in the app module.</p>\n<pre><code class=\"language-typescript\">// src/app.module.ts\n\n@Module({\n  imports: [],\n  controllers: [AppController, BalancesController, AllowancesController],\n  providers: [AppService, PolkadotApiService, ContractService],\n})\nexport class AppModule { }\n</code></pre>\n<p>Change the <code>ContractService</code> to implement the <code>Erc20</code> interface. Remove the <code>OnModuleInit</code> interface and the corresponding function. Inject the <code>PolkadotApiService</code> and use its <code>api</code>, <code>apiContract</code>, <code>abi</code> variables instead of the local ones. Change the transaction sender from fixed <code>alice</code> to the one chosen by a user. In the contract calls, which do not create a transaction (like <code>totalSupply</code>) we still need to pass some account, just as we need to pass the gas limit. The account will not however be charged, so let's stick to Alice in those cases.</p>\n<pre><code class=\"language-typescript\">// src/contract.service.ts\n\nimport { Injectable, Logger } from '@nestjs/common';\nimport { SubmittableResult } from '@polkadot/api';\nimport { ContractCallOutcome } from '@polkadot/api-contract/types';\nimport { Erc20 } from './erc20.interface';\nimport { ACCOUNTS, ERC20, PolkadotApiService } from './polkadot-api.service';\n\n@Injectable()\nexport class ContractService implements Erc20 {\n  constructor(private readonly polkadotApiService: PolkadotApiService) { }\n\n  async totalSupply() {\n    const result: ContractCallOutcome = await this.polkadotApiService.apiContract.call('rpc', 'totalSupply', 0, 1000000000000)\n      .send(ACCOUNTS.ALICE.address) as ContractCallOutcome\n    return result.output.toString()\n  }\n\n  async balanceOf(who: string) {\n    const result: ContractCallOutcome = await this.polkadotApiService.apiContract.call('rpc', 'balanceOf', 0, 1000000000000, ACCOUNTS[who].address)\n      .send(ACCOUNTS.ALICE.address) as ContractCallOutcome\n    return result.output.toString()\n  }\n\n  async transfer(sender: string, to: string, value: number) {\n    await this.polkadotApiService.api.tx.contracts.call(ERC20, 0, 1000000000000, this.polkadotApiService.abi.messages.transfer(ACCOUNTS[to].address, value))\n      .signAndSend(ACCOUNTS[sender].pair, (result: SubmittableResult) => { Logger.log(result) })\n  }\n\n  async allowance(owner: string, spender: string) {\n    const result: ContractCallOutcome = await this.polkadotApiService.apiContract.call('rpc', 'allowance', 0, 1000000000000, ACCOUNTS[owner].address, ACCOUNTS[spender].address)\n      .send(ACCOUNTS.ALICE.address) as ContractCallOutcome\n    return result.output.toString()\n  }\n\n  async approve(sender: string, spender: string, value: number) {\n    await this.polkadotApiService.api.tx.contracts.call(ERC20, 0, 1000000000000, this.polkadotApiService.abi.messages.approve(ACCOUNTS[spender].address, value))\n      .signAndSend(ACCOUNTS[sender].pair, (result: SubmittableResult) => { Logger.log(result) })\n  }\n\n  async transferFrom(sender: string, from: string, to: string, value: number) {\n    await this.polkadotApiService.api.tx.contracts.call(ERC20, 0, 1000000000000, this.polkadotApiService.abi.messages.transferFrom(ACCOUNTS[from].address, ACCOUNTS[to].address, value))\n      .signAndSend(ACCOUNTS[sender].pair, (result: SubmittableResult) => { Logger.log(result) })\n  }\n}\n</code></pre>\n<p>We can now add a new service to use the Substrate Runtime. Create <code>RuntimeService</code> which implements <code>Erc20</code>, inject <code>PolkadotApiService</code> and add empty functions to conform to the interface. Don't forget to register the service in the app module.</p>\n<pre><code class=\"language-typescript\">// src/runtime.service.ts\n\n@Injectable()\nexport class RuntimeService implements Erc20 {\n  constructor(private readonly polkadotApiService: PolkadotApiService) { }\n\n  async totalSupply() {}\n  async balanceOf(who: string) {}\n  async transfer(sender: string, to: string, value: number) {}\n  async allowance(owner: string, spender: string) {}\n  async approve(sender: string, spender: string, value: number) {}\n  async transferFrom(sender: string, from: string, to: string, value: number) {}\n</code></pre>\n<pre><code class=\"language-typescript\">// src/app.module.ts\n\n@Module({\n  imports: [],\n  controllers: [AppController, BalancesController, AllowancesController],\n  providers: [AppService, PolkadotApiService, ContractService, RuntimeService],\n})\n</code></pre>\n<p>To use the new service in the controllers, we will make some changes in them. To easily interact with the API and dynamically choose between the runtime and smart contract services add a <code>:service</code> param in the controller's path. Add a <code>tokenService</code> variable which we will assign the selected service to. Change the constructor to inject both services and the request and assign the <code>tokenService</code> with a proper service instance.</p>\n<pre><code class=\"language-typescript\">// src/balances.controller.ts\n\n@Controller(':service/balances')\nexport class BalancesController {\n  tokenService: Erc20;\n  constructor(@Inject(REQUEST) private readonly request: Request, private readonly runtimeService: RuntimeService, private readonly contractService: ContractService) {\n    this.tokenService = request.params.service === 'runtime' ? runtimeService : contractService;\n  }\n...\n}\n</code></pre>\n<h3>Query balances</h3>\n<p>Let's now implement the functions in our Runtime service. To implement the <code>totalSupply()</code> function, we will use the <code>ApiPromise</code> object from <code>polkadotApiService</code>. The api is structured as <code>api.&#x3C;type>.&#x3C;module>.&#x3C;section></code>.</p>\n<ul>\n<li>\n<p><code>type</code> - this is the type of a call we want to make. There are a few types:</p>\n<ul>\n<li><code>const</code> - for accessing runtime constants.</li>\n<li><code>rpc</code> - this is the backbone for the transmission of data to and from the node. The following API endpoints just wrap RPC calls, providing information in the encoded format as expected by the node.</li>\n<li><code>query</code> - for reading the current chain state.</li>\n<li><code>tx</code> - for sending and submitting transactions.</li>\n</ul>\n</li>\n<li><code>module</code> - this is the name of the module we want to access, i.e. <code>erc20</code> module we have just created.</li>\n<li><code>section</code> - a function we want to call (always in <code>camelCase</code> although in Rust we declared the functions in <code>snke_case</code>).</li>\n</ul>\n<p>To get the total supply of our token we will use <code>api.query.erc20.totalSupply()</code> function, await for the result, and return it.</p>\n<pre><code class=\"language-typescript\">async totalSupply() {\n  const result = await this.polkadotApiService.api.query.erc20.totalSupply()\n  return result\n}\n</code></pre>\n<p>Retrieving the balance of an account is quite similar, we only need to pass the account as a parameter. We will use the <code>ACCOUNTS</code> array imported from the <code>polkadot-api.service.ts</code>, so that we can use the names instead of hashes when interacting with our api.</p>\n<pre><code class=\"language-typescript\">async balanceOf(who: string) {\n  const result = await this.polkadotApiService.api.query.erc20.balanceOf(ACCOUNTS[who].address)\n  return result\n}\n</code></pre>\n<p>Run the backend app with <code>yarn start:dev</code> command and check the results in the browser. You should be able to successfully call <code>http://localhost:3000/runtime/balances</code> as well as <code>http://localhost:3000/contract/balances</code> and receive the corresponding values. You can also try to get Alice's or Bob's balances.</p>\n<h3>Transfer tokens</h3>\n<p>It is time to make a transaction and transfer some tokens. We will use <code>api.tx.erc20.transfer()</code> function. We need to pass three parameters: the transaction sender, the receiver, and the value. Once the transaction is created we need to sign and send it. To sign the transaction we will use the KeyringPair we have created earlier in the PolkadotApiService. We can also submit to the results to view them.</p>\n<pre><code class=\"language-typescript\">async transfer(sender: string, to: string, value: number) {\n  await this.polkadotApiService.api.tx.erc20.transfer(ACCOUNTS[to].address, value)\n    .signAndSend(ACCOUNTS[sender].pair, (result: SubmittableResult) => { Logger.log(result) })\n}\n</code></pre>\n<p>Let's send a PUT request at <code>http://localhost:3000/runtime/balances</code> to transfer some tokens from Alice to Bob and review the logs. </p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image10.png\"></p>\n<p>We will see three results: an empty one upon transaction creation, one with <code>InBlock</code> status when the transaction was included in a block, and one with <code>Finalized</code> status when the transaction was finalized and cannot be forked off the chain. The transaction gets finalized even if business logic fails (i.e. you try to transfer more funds than you poses). When you look at the second logged message, you can find an <code>event</code> object which includes events and errors emitted by the runtime functions.</p>\n<pre><code class=\"language-json\">\"event\": {\n  \"index\": \"0x0401\",\n  \"data\": [\n    \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\",\n    \"5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty\",\n    1000\n  ]\n}\n</code></pre>\n<p>This is exactly the event we have emitted from the runtime transfer function. You can see the account addresses to transfer from <code>5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY</code> and to <code>5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty</code> and the value of <code>1000</code>.</p>\n<p>Let's now try to make a transfer for a larger amount than we possess. To make sure how much we can spend, check it here <code>http://localhost:3000/runtime/balances/ALICE</code>. We can again look at the <code>event</code> object:</p>\n<pre><code class=\"language-json\">\"event\": {\n  \"index\": \"0x0001\",\n  \"data\": [\n    {\n      \"Module\": {\n        \"index\": 8,\n        \"error\": 1\n      }\n    },\n    {\n      \"weight\": 10000,\n      \"class\": \"Normal\",\n      \"paysFee\": \"Yes\"\n    }\n  ]\n},\n</code></pre>\n<p>In the <code>data</code> array we have information about the error. The <code>Module</code> object has two elements: </p>\n<ul>\n<li>\n<p><code>index</code> - the index of a module defined in the <code>Runtime</code> enum. You can find it in runtime's <code>lib.rs</code> file in <code>construct_runtime</code> macro:</p>\n<pre><code class=\"language-rust\">// substrate-node-template/runtime/src/lib.rs\n</code></pre>\n</li>\n</ul>\n<p>construct<em>runtime!(\npub enum Runtime where\nBlock = Block,\nNodeBlock = opaque::Block,\nUncheckedExtrinsic = UncheckedExtrinsic\n{\nSystem: system::{Module, Call, Config, Storage, Event<T>},\nRandomnessCollectiveFlip: randomness</em>collective<em>flip::{Module, Call, Storage},\nTimestamp: timestamp::{Module, Call, Storage, Inherent},\nAura: aura::{Module, Config<T>, Inherent(Timestamp)},\nGrandpa: grandpa::{Module, Call, Storage, Config, Event},\nBalances: balances::{Module, Call, Storage, Config<T>, Event<T>},\nTransactionPayment: transaction</em>payment::{Module, Storage},\nSudo: sudo::{Module, Call, Config<T>, Storage, Event<T>},\n// Used for the module erc20 in <code>./erc20.rs</code>\nErc20: erc20::{Module, Call, Storage, Event<T>},\nContracts: contracts::{Module, Call, Config, Storage, Event<T>},\n}\n);</p>\n<pre><code>* `error` - the index of the emitted error. The error enum is defined in the `decl_error` macro in our pallet's `lib.rs` file\n\n```rust\n// substrate-node-template/pallets/erc20/src/lib.rs\n\ndecl_error! {\n    pub enum Error for Module&#x3C;T: Trait> {\n        /// Attempted to initialize the token after it had already been initialized.\n        AlreadyInitialized,\n        /// Attempted to transfer more funds than were available\n        InsufficientFunds,\n            /// Attempted to transfer more funds than approved\n        InsufficientApprovedFunds,\n    }\n}\n</code></pre>\n<p>We can obtain the detailed names from a metadata object. It includes all the descriptive information about runtime modules, their storage, events, dispatchables and errors. To get the metadata of the runtime we query the runtime state object. </p>\n<pre><code class=\"language-typescript\">const metadata = await this.polkadotApiService.api.rpc.state.getMetadata() as Metadata;\n</code></pre>\n<p>The metadata contains information for each version of the runtime, but we want to get just the latest one, thus we use <code>.asLatest</code>.</p>\n<pre><code class=\"language-typescript\">result.events.forEach(({ event }) => {\n      event.data.forEach(async el => {\n        const module = el.toJSON()[\"Module\"];\n        if (module !== undefined &#x26;&#x26; module.index !== undefined &#x26;&#x26; module.error !== undefined) {\n          Logger.log(metadata.asLatest.modules[module.index].name); // Erc20\n          Logger.log(metadata.asLatest.modules[module.index].errors[module.error].name); // InsufficientFunds   \n          Logger.log(metadata.asLatest.modules[module.index].errors[module.error].documentation); // Attempted to transfer more funds than were available\n        }\n      })\n    })\n</code></pre>\n<h3>Approval</h3>\n<p>We now need to implement the approval feature. We need to add three functions to our runtime service - for retrieving allowances, for adding an approval and for transferring on behalf. It is quite straightforward, as we just need to dispatch the corresponding functions from our runtime and sign and send them with a selected account.</p>\n<pre><code class=\"language-typescript\">async allowance(owner: string, spender: string) {\n    const result = await this.polkadotApiService.api.query.erc20.allowance([ACCOUNTS[owner].address, ACCOUNTS[spender].address])\n    return result\n  }\n\n  async approve(sender: string, spender: string, value: number) {\n    await this.polkadotApiService.api.tx.erc20.approve(ACCOUNTS[spender].address, value)\n      .signAndSend(ACCOUNTS[sender].pair, (result: SubmittableResult) => { Logger.log(result) })\n  }\n\n  async transferFrom(sender: string, from: string, to: string, value: number) {\n    await this.polkadotApiService.api.tx.erc20.transferFrom(ACCOUNTS[from].address, ACCOUNTS[to].address, value)\n      .signAndSend(ACCOUNTS[sender].pair, (result: SubmittableResult) => { Logger.log(result) })\n  }\n</code></pre>\n<p>We also need to change the <code>AllowancesController</code> to use the <code>RuntimeService</code>.</p>\n<pre><code class=\"language-typescript\">// src/allowances.controller.ts\n\n@Controller(':token/allowances')\nexport class AllowancesController {\n  tokenService: Erc20;\n  constructor(@Inject(REQUEST) private readonly request: Request, private readonly runtimeService: RuntimeService, private readonly contractService: ContractService) {\n    this.tokenService = request.params.token === 'runtime' ? runtimeService : contractService;\n  }\n...\n</code></pre>\n<p>We can now let Alice approve Charlie to make some transfers on behalf of her.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image11.png\"></p>\n<p>If everything goes as it should, Charlie can now send some tokens from Alice to Bob.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image12.png\"></p>\n<p>Unfortunately, such a transfer produces <code>Internal server error</code>. It should say something like <code>1010: Invalid Transaction: Inability to pay some fees (e.g. account balance too low)</code>. It could look like we have some bug and try to transfer tokens from Charlie's account, which is empty for now. However, the reason is a little different. By default, for transaction fees Substrate uses the token from <code>Balances</code> pallet. In Polkadot JS Apps you <em>Accounts</em> -> <em>Accounts</em> page you can see each account's balance represented in the <code>Balances</code> pallet's tokens. When you start a pure chain in development mode Alice and Bob are the only accounts minted with some tokens.</p>\n<p>First of all, we need to fix our code to respond gently when an error occurs. The simplest way would be to add a <code>try-catch</code> block in the <code>BalancesController</code> function for transferring and throw an <code>HttpException</code> in the <code>catch</code> block.</p>\n<pre><code class=\"language-typescript\">// src/balances.controller.ts\n\n@Put()\n  @HttpCode(202)\n  async transfer(@Body() transferDto: TransferDto) {\n    try {\n      if (transferDto.from !== undefined) {\n        await this.tokenService.transferFrom(transferDto.sender, transferDto.from, transferDto.to, transferDto.value);\n      }\n      else {\n        await this.tokenService.transfer(transferDto.sender, transferDto.to, transferDto.value);\n      }\n    }\n    catch (err) {\n      throw new HttpException(err.message, HttpStatus.BAD_REQUEST)\n    }\n  }\n</code></pre>\n<p>Let's try to send the request again and confirm that we get the <code>400</code> response instead of <code>500</code>.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image13.png\"></p>\n<p>Now we can transfer some basic Substrate tokens from Alice do Charlie, to let him pay a transaction fee. Go to Polkadot JS Apps and choose <em>Accounts</em> -> <em>Accounts</em> page. Click <code>send</code> button in Alice's row and transfer 10 units from Alice do Charlie.</p>\n<p><img src=\"/images/cryptocurrency-with-substrate-2-image14.png\"></p>\n<p>Charlie can finally send 100 tokens from Alice to Bob. We can check that the approval was reduced by 100 and now it is 100. Charlie can try to transfer another 150 tokens from Alice to Bob. We should receive an event with the <code>InsufficientApprovedFunds</code> error.</p>\n<h2>Summary</h2>\n<p>In this blog post, we have looked through the implementation of the ERC20 token in a Substrate Runtime module. We have also created a NestJS app that reads data exposed by the module, calls the dispatchable functions and shows the emitted events and errors.</p>","excerpt":"This is the second part of a series where we are implementing an ERC20 token with a Substrate node and accessing it from a NestJS…","frontmatter":{"slug":null,"title":"Develop your own cryptocurrency with Substrate Part 2","description":null,"author":"agnieszka","tags":["substrate","parity","blockchain","nest","nestjs","erc20","cryptocurrency","rust"],"date":"2020-09-14T18:36:27.941Z","image":"/images/cryptocurrency_with_substrate1-–-4.png"},"timeToRead":20,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-09-15-develop-your-own-cryptocurrency-with-substrate-2.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-09-15-develop-your-own-cryptocurrency-with-substrate-2.md"}}}