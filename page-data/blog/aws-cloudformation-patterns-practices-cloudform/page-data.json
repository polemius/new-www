{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/aws-cloudformation-patterns-practices-cloudform","result":{"data":{"markdownRemark":{"html":"<p>Recently we introduced <a href=\"https://brightinventions.pl/blog/introducing-cloudform-tame-aws-cloudformation-templates/\"><code>cloudform</code></a> – our <a href=\"https://www.npmjs.com/package/cloudform\">open-source library</a> that allows for managing <a href=\"https://aws.amazon.com/cloudformation/\">AWS CloudFormation</a> template files through TypeScript. Its core value proposition is to cope with the massive JSON files in a sane and familiar way – to treat it as any other TypeScript code we have in our project. But what does it actually mean? Let's look at some examples to check where this path can lead us to.</p>\n<p>Just as a recap, the basic <code>cloudform</code> usage allows us to replace the lengthy and verbose JSON definition of AWS CloudFormation resource, like this:</p>\n<pre><code class=\"language-json\">{\n  \"VPC\": {\n    \"Type\": \"AWS::EC2::VPC\",\n    \"Properties\": {\n      \"CidrBlock\": {\n        \"Fn::FindInMap\": [\n          \"NetworkingConfig\",\n          \"VPC\",\n          \"CIDR\"\n        ]\n      },\n      \"EnableDnsHostnames\": true,\n      \"Tags\": [\n        {\n          \"Key\": \"Application\",\n          \"Value\": {\n            \"Ref\": \"AWS::StackName\"\n          }\n        },\n        {\n          \"Key\": \"Network\",\n          \"Value\": \"Public\"\n        },\n        {\n          \"Key\": \"Name\",\n          \"Value\": {\n            \"Fn::Join\": [\n              \"-\",\n              [\n                {\n                  \"Ref\": \"AWS::StackId\"\n                },\n                \"VPC\"\n              ]\n            ]\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<p>into totally equivalent piece of TypeScript:</p>\n<pre><code class=\"language-typescript\">{\n  VPC: new EC2.VPC({\n      CidrBlock: Fn.FindInMap('NetworkingConfig', 'VPC', 'CIDR'),\n      EnableDnsHostnames: true,\n      Tags: [\n          new ResourceTag('Application', Refs.StackName),\n          new ResourceTag('Network', 'Public'),\n          new ResourceTag('Name', Fn.Join('-', [Refs.StackId, 'VPC']))\n      ]\n  })\n}\n</code></pre>\n<p>Let's try something more.</p>\n<h2>Get rid of repetitive values</h2>\n<p>Some references or other variables in our template repeat many times. With <code>cloudform</code> it's a bit more concise than in pure JSON – compare <code>Refs.StackName</code> to <code>{\"Ref\": \"AWS::StackName\"}</code>. We also often reference more complex constructs like concatenations – in pure JSON it quickly grows complex:</p>\n<pre><code class=\"language-json\">{\n  \"Fn::Join\": [\n    \"-\",\n    [\n      \"app-name-\",\n      {\n        \"Ref\": \"DeployEnv\"\n      }\n    ]\n  ]\n}\n</code></pre>\n<p>With <code>cloudform</code> the same is expressed as </p>\n<pre><code class=\"language-typescript\">Fn.Join('-', ['app-name-', Fn.Ref('DeployEnv')])\n</code></pre>\n<p>But if we reference this kind of value several times, we can just save it as a TypeScript-level constant and just reference it in TypeScript:</p>\n<pre><code class=\"language-typescript\">const envAppName = Fn.Join('-', ['app-name-', Fn.Ref('DeployEnv')])\n\nexport default cloudform({\n    // ...\n    ParameterValueSomewhereInResources: envAppName\n})\n</code></pre>\n<p><img src=\"/images/cloudform/mindmap.jpg\" alt=\"Structure and order for our AWS CloudFormation templates\"></p>\n<h2>Get rid of repetitive resources</h2>\n<p>The same concept applies well for similar resources definitions. Let's say we need ten SQS queues defined in our infrastructure. In pure JSON it means we have to repeat the same queue definition piece over and over again, changing probably just a name parameter.</p>\n<pre><code class=\"language-json\">{\n  \"NthQueue\": {\n    \"Type\": \"AWS::SQS::Queue\",\n    \"Properties\": {\n      \"QueueName\": {\n        \"Fn::Join\": [\n          \"-\",\n          [\n            {\n              \"Ref\": \"DeployEnv\"\n            },\n            \"nth-queue\"\n          ]\n        ]\n      },\n      \"RedrivePolicy\": {\n        \"maxReceiveCount\": 4,\n        \"deadLetterTargetArn\": {\n          \"Fn::GetAtt\": [\n            \"DefaultDeadLetterQueue\",\n            \"Arn\"\n          ]\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>Going further with our previous concept of removing repetitions, we can apply pretty standard refactoring – extract a method. So we can define the piece of TypeScript that generates the Queue resource object and just invoke it within our template for each queue to be defined:</p>\n<pre><code class=\"language-typescript\">const defineQueue = (name: string) => {\n    return new SQS.Queue({\n        QueueName: Fn.Join('-', [Fn.Ref('DeployEnv'), name, 'queue']),\n        RedrivePolicy: {\n            maxReceiveCount: 4,\n            deadLetterTargetArn: Fn.GetAtt('DefaultDeadLetterQueue', 'Arn')\n        }\n    })\n}\n\nexport default cloudform({\n    Resources: {\n        Queue1: defineQueue(\"first\"),\n        Queue2: defineQueue(\"second\"),\n        // ...\n        QueueN: defineQueue(\"nth\")\n    }\n})\n</code></pre>\n<h2>Get rid of static FindInMap</h2>\n<p>It often makes sense to have some common configuration values grouped together and possibly different depending on some parameter, for example a deployment environment like staging vs. production. In a pure JSON template we can use <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-findinmap.html\"><code>Fn::FindInMap</code></a> to reach the desired value where it is needed. We need to pass all the keys as a path to our value, possibly using parameter references (<code>Ref</code>) or other variables. But if our path is static, with <code>cloudform</code> we might get rid of verbose map accessing and replace it with a native TypeScript object instead.</p>\n<p>So instead of:</p>\n<pre><code class=\"language-json\">{\n  \"Mappings\": {\n    \"NetworkingConfig\": {\n      \"VPC\": {\n        \"CIDR\": \"0.0.0.0/16\"\n      }\n    }\n  },\n  \"Resources\": {\n    \"VPC\": {\n      \"Type\": \"AWS::EC2::VPC\",\n      \"Properties\": {\n        \"CidrBlock\": {\n          \"Fn::FindInMap\": [\n            \"NetworkingConfig\",\n            \"VPC\",\n            \"CIDR\"\n          ]\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>we might create this mapping in TypeScript directly:</p>\n<pre><code class=\"language-typescript\">const NetworkingConfig = {\n    VPC: {\n        CIDR: \"0.0.0.0/16\"\n    }\n}\n\nexport default cloudform({\n    Resources: new EC2.VPC({\n        CidrBlock: NetworkingConfig.VPC.CIDR\n    })\n})\n</code></pre>\n<h2>Split into multiple files</h2>\n<p>Nobody likes large source files. And complex environment definitions tend to grow large. In pure JSON, we are not able to split the file easily. There is an option to <a href=\"http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/create-reusable-transform-function-snippets-and-add-to-your-template-with-aws-include-transform.html\">import external snippets</a>, but it requires the snippet to be located on S3. Kind of cumbersome if we want to properly keep our infrastructure in source control and be serious in our <a href=\"https://www.infoq.com/code-infrastructure\">infrastructure-as-code approach</a>.</p>\n<p>With <code>cloudform</code> we are in the TypeScript world and nothing should stop us from treating parts of our template as TypeScript modules that can be imported into the final template. It might make sense to separate our networking stack module from the instances module and from the database module etc. – where each module might keep all the resources logically bound together – database access-related security groups might be defined together with the database, but ECS-related security groups might be defined together with the containers.</p>\n<p>Let's look at the database module example, <code>database.ts</code>:</p>\n<pre><code class=\"language-typescript\">export default {\n  DatabaseInstanceParameters: new RDS.DBParameterGroup({\n    Family: \"postgres9.6\"\n  }),\n  DatabaseInstance: new RDS.DBInstance({\n    DBName: Fn.Join('-', ['db', Fn.Ref('DeployEnv')]),\n    DBParameterGroupName: Fn.Ref('DatabaseInstanceParameters'),\n    VPCSecurityGroups: [\n        Fn.GetAtt('DatabaseSecurityGroup', 'GroupId')\n    ]\n    // ...\n  }),\n  DatabaseSecurityGroup: new EC2.SecurityGroup({\n    // ...\n  })\n}\n</code></pre>\n<p>And its usage within the actual template:</p>\n<pre><code class=\"language-typescript\">import databaseResources from './database'\n\nexport default cloudform({\n  Resources: Object.assign({}, databaseResources, /* and possibly more */)\n})\n</code></pre>\n<h2>Forget the actual JSON at all</h2>\n<p>With all the <code>cloudform</code> goodies around, we might forget the existence of the JSON file within our sources. It might make sense to generate it on the fly as a part of our build or deployment process. How about adding the template generation task to our NPM scripts:</p>\n<pre><code class=\"language-json\">{\n  \"generate-aws-template\": \"cloudform cloudformation/.ts > .build/template.out\",\n  \"deploy\": \"npm run generate-aws-template &#x26;&#x26; &#x3C;proceed with deployment using .build/template.out>\"\n}\n</code></pre>\n<p>There are probably a lot of other creative ways to use <code>cloudform</code> to simplify and manage our AWS CloudFormation templates. Feel free to share your ideas!</p>","excerpt":"Recently we introduced cloudform – our open-source library that allows for managing AWS CloudFormation template files through TypeScript…","frontmatter":{"slug":null,"title":"AWS CloudFormation patterns & practices with cloudform","description":null,"author":"adam","tags":["AWS","CloudFormation","open-source"],"date":"2017-12-14T23:00:00.000Z","image":"/images/cloudform/mindmap.jpg"},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-15-aws-cloudformation-patterns-practices-cloudform.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-15-aws-cloudformation-patterns-practices-cloudform.md"}}}