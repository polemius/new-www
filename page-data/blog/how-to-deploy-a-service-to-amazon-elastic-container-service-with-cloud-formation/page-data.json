{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/how-to-deploy-a-service-to-amazon-elastic-container-service-with-cloud-formation","result":{"data":{"markdownRemark":{"html":"<p>Containers are becoming the standard way of deploying software. Every cloud vendor now offers one or multiple ways to run containers on their platform. Most of our clients uses AWS to host their SaaS solution. As part of a new development for one of our clients we have decided to move away from <a href=\"https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html\">Elastic Beanstalk</a> and embrace containers. Amazon <a href=\"https://aws.amazon.com/ecs/\">Elastic Container Service</a> is an orchestration service that supports Docker containers and is generally available for over a year. Given our small development team it seemed like the best choice since it takes away most of the cluster management headaches. In this post I will describe how we deploy a container to ECS using <a href=\"https://aws.amazon.com/cloudformation/\">CloudFormation</a>.</p>\n<p><img src=\"/images/ecs-service/containers.jpeg\" alt=\"containers\"></p>\n<h1>ECS Cluster definition</h1>\n<p>At <a href=\"https://brightinventions.pl/\">Bright Inventions</a> we often use CloudFormation for infrastructure configuration since it allows us to version and track changes easily. The first piece of infrastructure we need is an <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_clusters.html\">ECS cluster</a>. A cluster is a logical group of tasks/containers running inside ECS. In particular, since we will be using <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html\">EC2 Launch Type</a>, a cluster can also be though of as a group of EC2 instances with an ECS Agent installed.</p>\n<pre><code class=\"language-json\">\"ECSMainCluster\": {\n    \"Type\": \"AWS::ECS::Cluster\",\n    \"Properties\": {\n        \"ClusterName\": \"app-stack-main\"\n    }\n},\n\"ECSAutoScalingGroup\": {\n    \"Type\": \"AWS::AutoScaling::AutoScalingGroup\",\n    \"Properties\": {\n        \"VPCZoneIdentifier\": [\n            { \"Ref\": \"PrivateASubnet\" },\n            { \"Ref\": \"PrivateBSubnet\" }\n        ],\n        \"LaunchConfigurationName\": {\n            \"Ref\": \"ContainerHostInstances\"\n        },\n        \"MinSize\": \"1\",\n        \"MaxSize\": \"6\",\n        \"DesiredCapacity\": \"1\",\n        \"Tags\": [\n            {\n                \"Key\": \"Name\",\n                \"Value\": \"app-stack-ecs\",\n                \"PropagateAtLaunch\": true\n            }\n        ]\n    },\n    \"CreationPolicy\": {\n        \"ResourceSignal\": {\n            \"Timeout\": \"PT5M\"\n        }\n    },\n    \"UpdatePolicy\": {\n        \"AutoScalingReplacingUpdate\": {\n            \"WillReplace\": \"true\"\n        }\n    }\n}\n</code></pre>\n<p>As you can see above, the <code>ECSMainCluster</code> is mostly a declaration. What follows is an auto scaling group that will launch and manage EC2 instances. The <code>VPCZoneIdentifier</code> lists 2 VPC subnets created in separate availability zones. This is vital for availability as it causes the EC2 instances to run on physically separate hardware. For brevity, I've omitted their configuration from this post. However, if you are interested in this topic head over <a href=\"https://sookocheff.com/post/aws/how-to-create-a-vpc-using-cloudformation/\">to this post</a>. The specified <code>LaunchConfigurationName</code> named <code>ContainerHostInstances</code> details how the EC2 instance should look like.</p>\n<pre><code class=\"language-json\">\"ContainerHostInstances\": {\n    \"Type\": \"AWS::AutoScaling::LaunchConfiguration\",\n    \"Properties\": {\n        \"ImageId\": \"ami-880d64f1\",\n        \"SecurityGroups\": [\n            { \"Ref\": \"ECSSecurityGroup\" }\n        ],\n        \"InstanceType\": \"t2.medium\",\n        \"IamInstanceProfile\": { \"Ref\": \"ECSHostEC2InstanceProfile\" },\n        \"KeyName\": \"private-key-pair\",\n        \"UserData\": {\n            \"Fn::Base64\": {\n                \"Fn::Join\": [\n                    \"\",\n                    [\n                        \"#!/bin/bash -xe\\n\",\n                        \"echo ECS_CLUSTER=\",\n                        {\n                            \"Ref\": \"ECSMainCluster\"\n                        },\n                        \" >> /etc/ecs/ecs.config\\n\",\n                        \"yum install -y aws-cfn-bootstrap\\n\",\n                        \"/opt/aws/bin/cfn-signal -e $? \",\n                        \"         --stack \",\n                        {\n                            \"Ref\": \"AWS::StackName\"\n                        },\n                        \"         --resource ECSAutoScalingGroup \",\n                        \"         --region \",\n                        {\n                            \"Ref\": \"AWS::Region\"\n                        },\n                        \"\\n\"\n                    ]\n                ]\n            }\n        }\n    }\n},\n\"ECSHostEC2InstanceProfile\": {\n    \"Type\": \"AWS::IAM::InstanceProfile\",\n    \"Properties\": {\n        \"Path\": \"/\",\n        \"Roles\": [\n            {\n                \"Ref\": \"ECSHostEC2Role\"\n            }\n        ]\n    }\n},\n</code></pre>\n<p>The first important property is the <code>ImageId</code> which uses <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-optimized_AMI.html\">Amazon ECS-optimized Linux AMI ID</a>. Next we have a security group that adds rules for incoming traffic on application ports. Next we have <code>IamInstanceProfile</code> which references an instance profile <code>ECSHostEC2InstanceProfile</code> that in turn <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html\">assumes a role policy required by the ECS Agent</a> to deploy and configure containers.\nInside <code>UserData</code> we define a shell script that informs ECS Agent about the cluster it is running in. I will omit <code>ECSHostEC2Role</code> definition since <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html\">it is well described in the documentation</a>.</p>\n<p>With the above we are now ready to deploy an ECS Cluster through CloudFormation template. However, a cluster without containers is pretty meaningless.</p>\n<h1>ECS Service and Task definition</h1>\n<p>In AWS lingo <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html\">an ECS Service</a> describes a minimal configuration required to deploy and run a Task Definition. A <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html\">Task Definition</a> in turn describes how to configure and run a set of containers that form a single logical component.</p>\n<pre><code class=\"language-json\">\"EmailSenderService\": {\n    \"Type\": \"AWS::ECS::Service\",\n    \"Properties\": {\n        \"Cluster\": { \"Ref\": \"ECSMainCluster\" },\n        \"DesiredCount\": 2,\n        \"DeploymentConfiguration\": { \"MinimumHealthyPercent\": 50 },\n        \"Role\": { \"Ref\": \"ECSServiceRole\" },\n        \"TaskDefinition\": { \"Ref\": \"EmailSenderTask\" }\n    }\n},\n\"EmailSenderTask\": {\n    \"Type\": \"AWS::ECS::TaskDefinition\",\n    \"Properties\": {\n        \"Family\": \"app-stack-email-sender\",\n        \"ContainerDefinitions\": [{\n            \"Name\": \"app-stack-email-sender\",\n            \"Essential\": \"true\",\n            \"Image\": { \"Ref\": \"EmailSenderTaskDockerImage\" },\n            \"LogConfiguration\": {\n                \"LogDriver\": \"awslogs\",\n                \"Options\": {\n                    \"awslogs-group\": { \"Ref\": \"EmailSenderLogsGroup\" },\n                    \"awslogs-region\": { \"Ref\": \"AWS::Region\" },\n                    \"awslogs-stream-prefix\": \"email-sender\",\n                    \"awslogs-datetime-format\": \"%Y-%m-%d %H:%M:%S.%L\"\n                }\n            },\n            \"PortMappings\": [{ \"ContainerPort\": 8080 }],\n            \"Environment\": [{\n                \"Name\": \"DEPLOY_ENV\",\n                \"Value\": { \"Ref\": \"DeployEnv\" }\n            }]\n        }]\n    }\n},\n\"EmailSenderLogsGroup\": {\n    \"Type\": \"AWS::Logs::LogGroup\",\n    \"Properties\": {\n        \"LogGroupName\": \"app-stack-email-sender\",\n        \"RetentionInDays\": 14\n    }\n}\n</code></pre>\n<p>The <code>EmailSenderService</code> is pretty straightforward to understand. The <code>EmailSenderTask</code> defines a single container. The <code>app-stack-email-sender</code> task definition states that the <code>Image</code> is a reference to a parameter passed in to the CloudFormation template when creating or updating the stack. Its value must <a href=\"https://docs.docker.com/engine/reference/commandline/pull/#pull-from-a-different-registry\">be a name of a Docker image</a> that can be pulled by the ECS Agent. The repository can either be <a href=\"https://hub.docker.com/\">public</a> or private. When hosting your own, private Docker image repository you need to make sure the ECS Agent <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/private-auth.html\">has the correct credentials configured</a>. Thankfully there is <a href=\"https://aws.amazon.com/ecr/\">Elastic Container Registry</a> which offers private repositories that are automatically configured when using ECS as long as <code>ECSHostEC2Role</code> policy <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html\">allows ECR related actions</a>.</p>\n<p>Next we have the <code>LogConfiguration</code> that pushes containers logs to the <code>EmailSenderLogsGroup</code> CloudWatch Log Group so that we can can inspect them through AWS Console. The <code>PortMappings</code> lists ports exposed by a running container. Note that we have not defined the host port and it will get assigned automatically. This is important when running multiple instances of the same container. I'll describe it in a bit more detail in the next post. Last but not least the <code>Environment</code> section lists environment variables passed to the container instances on startup. Here we are referencing a <code>DeployEnv</code> stack parameter that allows us to inform the application running inside the container about the current deployment environment e.g. staging vs production.</p>\n<p>As you can see above it takes couple of steps to use CloudFormation to deploy a container to ECS. It is true that it requires more configuration than Elastic Beanstalk. However, it allows for better utilization of EC2 instances and an uniform approach to deployment and configuration regardless of the application technology used inside the container. Moreover it is more future proof as with few adjustments it should be possible to switch to <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html\">Fargate Launch Mode</a>. Using this mode releases us from the burden of EC2 ECS cluster management tasks. Deploying more services and tasks will require separate CloudFormation resource definitions. However, with the help of <a href=\"https://brightinventions.pl/blog/introducing-cloudform-tame-aws-cloudformation-templates/\">cloudform</a> it easy keep the CloudFormation template DRY.</p>","excerpt":"Containers are becoming the standard way of deploying software. Every cloud vendor now offers one or multiple ways to run containers on…","frontmatter":{"slug":null,"title":"How to deploy a service to Amazon Elastic Container Service with CloudFormation?","description":null,"author":"piotr","tags":["aws","ecs","cloudformation","zuul"],"date":"2018-02-18T23:00:00.000Z","image":"/images/ecs-service/containers.jpeg"},"timeToRead":6,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-19-how-to-deploy-a-service-to-amazon-elastic-container-service-with-cloud-formation.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-19-how-to-deploy-a-service-to-amazon-elastic-container-service-with-cloud-formation.md"}}}