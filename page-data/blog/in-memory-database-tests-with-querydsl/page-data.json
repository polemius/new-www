{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/in-memory-database-tests-with-querydsl","result":{"data":{"markdownRemark":{"html":"<p>Writing tests is an important skill of a software engineer. I used to write lots of very focused, narrow unit tests. However, I often found such tests to hinder refactoring and barely help in catching regressions. Whether such issues were caused by my poor design choices or are intrinsic to unit tests is not the focus of this post. However, the fact is that nowadays I tend to write more coarse-grained, integration style tests. There is one downside to such approach: speed. For instance, using Hibernate with a full fledged database is relatively slow compared to using a fake repository implementation. Today I write about abstracting the database access using <a href=\"http://www.querydsl.com/\">Querydsl</a> in a way that aids testing.</p>\n<p><img src=\"/images/querydsl-tests/test.jpg\" alt=\"test\"></p>\n<h1>Querydsl is awesome</h1>\n<p><a href=\"http://www.querydsl.com/\">Querydsl</a> is a set of libraries that, as the name implies, provides strongly typed Domain Specific Language to execute queries. <a href=\"http://www.querydsl.com/\">Querydsl</a> supports many data access technologies e.g. JDBC, Hibernate, JDO.\nThe following example in Kotlin illustrates how a DSL generated based on entity class can be used to find some entities through JPA interface:</p>\n<pre><code class=\"language-kotlin\">val queryFactory: JPAQueryFactory = ...\nval userEmailToSearch = \"alamakota@gmail.com\"\nval user = queryFactory.query()\n    .from(QUser.user)\n    .where(QUser.user.email.eq(userEmailToSearch))\n    .select(QUser.user)\n    .fetchOne()\n</code></pre>\n<p>One important option available is the <a href=\"https://github.com/querydsl/querydsl/tree/master/querydsl-collections\">Collections</a> module that offers an integration to POJO collections and beans. The following example in Kotlin shows how a list of users can be queried:</p>\n<pre><code class=\"language-kotlin\">val users = listOf(userAlan, userBob, userAlice)\nval user = CollQuery&#x3C;Nothing>()\n    .from(QUser.user, users)\n    .where(QUser.user.email.eq(userEmailToSearch))\n    .select(QUser.user)\n    .fetchOne()\n</code></pre>\n<h1>Abstract the complex away</h1>\n<p>The above examples look similar thanks to common interface provided by Querydsl. However, while the default DSL is very capable I found it a bit verbose in the most common cases. For that matter let us define a bit simpler interface that will allow for finding entities given some criteria</p>\n<pre><code class=\"language-kotlin\">interface EntityQueries {\n    fun &#x3C;TQEntity : EntityPath&#x3C;TEntity>, TEntity : Any> findFirst(\n        qEntity: TQEntity, \n        where: (TQEntity) -> Predicate? = { null }, \n        orderBy: ((TQEntity) -> OrderSpecifier&#x3C;*>?) = { null }): TEntity? \n}\n\nval queries:EntityQueries = ....\n\nval ala = queries.findFirst(QUser.user, where = { it.email.eq(\"ala@gmail.com\") })\nval latestUser = queries.findFirst(QUser.user, orderBy = { it.created.desc() })\n</code></pre>\n<p>The above interface allows us to express commonly used queries in a more succinct fashion.</p>\n<h1>Define production implementation</h1>\n<p>With Querydsl it is easy enough to implement the <code>EntityQueries</code> interface. First the production implementation delegating to JPA for actual data access technology:</p>\n<pre><code class=\"language-kotlin\">class QueryDslDomainQueryFactory(private val queryFactory: JPAQueryFactory) : EntityQueries {\n    override fun &#x3C;TQEntity : EntityPath&#x3C;TEntity>, TEntity : Any> findFirst(qEntity: TQEntity, where: (TQEntity) -> Predicate?, orderBy: (TQEntity) -> OrderSpecifier&#x3C;*>?): TEntity? {\n        return queryFactory.query()\n            .from(qEntity)\n            .where(where(qEntity))\n            .apply { orderBy(qEntity)?.let { this.orderBy(it) }  }\n            .select(qEntity)\n            .fetchFirst()\n    }\n}\n</code></pre>\n<p>The above lets us use the <code>EntityQueries</code> interface instead of JPA in e.g. Spring controllers like so:</p>\n<pre><code class=\"language-kotlin\">@RestController\nclass UsersController(private val queries: EntityQueries) {\n    @GetMapping(\"/users\")\n    fun getByEmail(@RequestParam email: String) = queries.findFirst(QUser.user, where = { it.email.eq(email) })\n}\n</code></pre>\n<p>One of the Spring recommended ways to abstract the specifics of query technology is to use <a href=\"https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods\">repository interfaces</a> e.g:</p>\n<pre><code class=\"language-kotlin\">interface UserRepository : Repository&#x3C;User, Long> {\n  fun findByEmail(String email): User?\n}\n</code></pre>\n<p>Such interface would be <em>magically</em> implemented by Spring runtime and put in the application context. The approach may seem appealing at first since we do not have to implement the interface. There are however, multiple issues:</p>\n<ul>\n<li>an application context is required which in turn is slow to bootstrap</li>\n<li>there is no compile time checks</li>\n<li>the refactoring is harder without a special support from IDE</li>\n<li>the actual behavior is hard to figure out without a careful documentation lecture (what will happen if e.g. there are multiple users with the same email?)</li>\n</ul>\n<p>The <code>EntityQueries</code> invocation to find users by email is almost as readable as <code>findByEmail</code> but does not suffer from any of downsides listed above. Encapsulating more complex filtering logic can be done with a simple extension method or a more elaborate <a href=\"https://en.wikipedia.org/wiki/Specification_pattern\">Specification pattern</a>. </p>\n<h1>Using in-memory database in tests</h1>\n<p>We can use Spring test helpers to ease writing tests involving an application context that lets us inject e.g. <code>UsersController</code> instance to invoke its methods. However, such tests are, comparatively, very slow to run and thus cause the feedback loop to be much slower. Fortunately the <code>EntityQueries</code> abstraction is very easy to implement using POJO in-memory collections.</p>\n<pre><code class=\"language-kotlin\">class InMemoryEntityQueries : QueriesBase(), EntityQueries {\n    val entities = mutableMapOf&#x3C;Class&#x3C;*>, MutableList&#x3C;*>>()\n\n    override fun &#x3C;TQEntity : EntityPath&#x3C;TEntity>, TEntity : Any> findFirst(qEntity: TQEntity, where: (TQEntity) -> Predicate?, orderBy: (TQEntity) -> OrderSpecifier&#x3C;*>?): TEntity? {\n        val entities = entities.getOrPut(qEntity.type, { mutableListOf&#x3C;TEntity>() }) as List&#x3C;TEntity>\n        return CollQuery&#x3C;Nothing>()\n            .from(qEntity, entities)\n            .where(where(qEntity))\n            .apply { orderBy(qEntity)?.let { this.orderBy(it) } }\n            .select(qEntity)\n            .fetchFirst()\n    }\n}\n</code></pre>\n<p>The above implementation looks almost exactly the same as the production one. We can of course try to extract the common code to make things more DRY. However, the most important observation is that we delegate to Querydsl implementation for the important filtering and ordering logic. This can increase our confidence that the fake implementation behaves the same as production one with only difference being the actual entity storage.</p>\n<p>Given the above implementation we can now easily replace the <code>UsersController</code> dependency and instantiate it as a regular POJO:</p>\n<pre><code class=\"language-kotlin\">class UsersControllerTests {\n    val db = InMemoryEntityQueries()\n    val controller = UsersController(db)\n\n    @Test\n    fun canFindByEmail(){\n        db.entities[User::class.java] =  listOf(User(email = \"ala@gmail.com\"), User(email = \"ola@gmail.com\"))\n\n        controller.getByEmail(\"ola@gmail.com\").email.shouldEqual(\"ola@gmail.com\")\n        controller.getByEmail(\"peter@gmail.com\").shouldEqual(null)\n    }\n}\n</code></pre>\n<h1>Notes on in-memory implementation</h1>\n<p>The <code>EntityQueries</code> interface above is obviously a simplified version. The most important missing piece is the ability to save entities. However, this is not a hard thing to implement given the in-memory implementation. We can, for instance, make use of the fact that all of our entities are marked JPA Persistence annotations to find a field marked with <code>@Id</code>, generate the id and assign it based on the contents of the <code>entities</code> variable. Another approach is to mark all entities with a dedicated interface e.g.</p>\n<pre><code class=\"language-kotlin\">interface HasId&#x3C;TId> {\n    var id: TId\n}\n</code></pre>\n<p>An entity implementing <code>HasId</code> could be checked in the <code>save</code> method of the in-memory implementation and assigned with a unique identifier e.g.:</p>\n<pre><code class=\"language-kotlin\">fun &#x3C;TEntity: HasId&#x3C;Long>> save(entity: TEntity) {\n    val entities = entities.getOrPut(entity.javaClass, { mutableListOf&#x3C;TEntity>() }) as List&#x3C;TEntity>\n    if(entity.id == null){\n        entity.id = (entities.map { it.id }.max() ?: 0) + 1\n    }\n    entities += entity\n}\n</code></pre>\n<p>Following the above approach we can easily add missing operations e.g. to remove an entity and that in turn allows us to write even more tests that run fully in-memory. It is worth noting that using an in-memory database implementation works best for queries that fetch, save or update one or multiple instances. As soon as we need to use a features natural to a database technology e.g. joins in SQL, we are better of connecting to a real database. While Querydsl collections module supports both join and group operations the in-memory implementation is often not equivalent to the database one especially around <code>null</code> values handling.</p>","excerpt":"Writing tests is an important skill of a software engineer. I used to write lots of very focused, narrow unit tests. However, I often found…","frontmatter":{"slug":null,"title":"In-memory database tests with Querydsl","description":null,"author":"piotr","tags":["kotlin","querydsl","hibernate","jpa","database"],"date":"2018-02-11T23:00:00.000Z","image":"/images/querydsl-tests/test.jpg"},"timeToRead":6,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-12-in-memory-database-tests-with-querydsl.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-12-in-memory-database-tests-with-querydsl.md"}}}