{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/erc20-substrate-nest-example","result":{"data":{"markdownRemark":{"html":"<p>In this blog post I will guide you through the process of implementing an ERC20 token with use of a smart contract on a Substrate node and accessing it from a NestJS application. If you would like to get a basic concept of what blockchain, Substrate or smart contracts are you may check our <a href=\"https://brightinventions.pl/blog/why-would-you-use-substrate/\">previous blog post</a>. NestJS is a framework for building Node.js applications, to get the basics you can visit it's <a href=\"https://docs.nestjs.com/\">documentation website</a>.</p>\n<p>You can access the <a href=\"https://github.com/bright/substrate-erc20-nestjs/tree/part1\">working project on GitHub</a>.</p>\n<h2>Substrate node</h2>\n<p>First of all we need a local substrate node. To have it on your computer it is best to complete the <a href=\"https://substrate.dev/docs/en/tutorials/create-your-first-substrate-chain/\">Create your first substrate chain tutorial from substrate.dev</a>.</p>\n<p>To be able to deploy a smart contract to the node, we need to add the Contracts Pallet. To do it, please complete the <a href=\"https://substrate.dev/docs/en/tutorials/add-a-pallet-to-your-runtime/\">Add a pallet to your runtime tutorial</a>. If you would like to skip this part, clone <a href=\"https://github.com/bright/substrate-erc20-nestjs/tree/part1\">this tutorial's repo</a> instead of the Substrate Node Template repo.</p>\n<h2>Run the Substrate node</h2>\n<p>If you decided to omit adding a Contracts Pallet on your own, you need to build the node. <code>cargo</code> is a package manager for Rust, which you should already have on your computer after completing <em>Create your first substrate chain</em> tutorial.</p>\n<pre><code class=\"language-shell\">cargo build --release\n</code></pre>\n<p>Purge the chain and run it in development mode with the following commands:</p>\n<pre><code class=\"language-shell\">./target/release/node-template purge-chain --dev\n</code></pre>\n<pre><code class=\"language-shell\">./target/release/node-template --dev\n</code></pre>\n<p>To make sure your chain is up and running you can use the <a href=\"https://polkadot.js.org/apps\">Polkadot JS Apps</a>. To run the app you need a Chromium based browser (other browsers will not allow you to connect to the local node). You can expand the list of available chains by clicking on the Substrate logo in the upper left corner. Expand <em>DEVELOPMENT</em> list and choose the <em>Local Node</em>.</p>\n<p><img src=\"/images/screenshot-2020-09-01-at-20.29.16.png\"></p>\n<p>To see if the Contracts Pallet was successfully added, check that you have the <em>Contracts -> Developer</em> page available.</p>\n<p><img src=\"/images/screenshot-2020-09-01-at-20.32.02.png\"></p>\n<h2>ERC20 token Smart Contract</h2>\n<p>ERC20 is the Ethereum token standard used for Ethereum Smart Contracts. It defines an interface for a simple cryptocurrency. Users can transfer tokens they own or allow other users to transfer some amount of tokens on their behalf.</p>\n<p>To build your own ERC20 token contract you can complete another tutorial available <a href=\"https://substrate.dev/substrate-contracts-workshop/#/\">here</a>. The first part will guide you through the basics of smart contract creation. The second part is strictly focused on the ERC20 token implementation.</p>\n<p>If you decide to skip this part, you can get the code from the <a href=\"https://github.com/bright/substrate-erc20-nestjs/tree/part1\">repository for this tutorial</a>.</p>\n<h2>Build the contract</h2>\n<p>Once you have the code of ERC20 ready you need to build and deploy it to the Substrate chain. If you have completed the tutorial from the previous point, you probably are already familiar with the process. If you haven't but still wish to build the contract on your own, you will need to install the ink! command line utility. You can also skip it and use the <code>.wasm</code> binary and metadata files uploaded to <a href=\"https://github.com/bright/substrate-erc20-nestjs/tree/part1/smart-contract/target\">this post's repository</a> and go straight to deploying the contract to the chain.</p>\n<p>Install the ink! command line utility.</p>\n<pre><code class=\"language-shell\">cargo install cargo-contract --vers 0.6.2 --force\n</code></pre>\n<p>Build the contract with the following command, which will create a <code>.wasm</code> file.</p>\n<pre><code class=\"language-shell\">cargo +nightly contract build\n</code></pre>\n<p>Generate metadata json file, which describes the smart contract.</p>\n<pre><code class=\"language-shell\">cargo +nightly contract generate-metadata\n</code></pre>\n<h2>Deploy contract to the chain</h2>\n<p>To deploy the contract, check the <a href=\"https://substrate.dev/substrate-contracts-workshop/#/0/deploying-your-contract\"><em>Deploying your contract</em> chapter from the tutorial</a>. When creating an instance of the contract, we need to pass the initial supply value, i.e. <code>1 000 000</code>. </p>\n<h2>Connecting from NestJS app</h2>\n<p>Now we are ready to communicate with our smart contract. There are several ways to do this. One obvious way would be to use the <a href=\"https://polkadot.js.org/apps\">Polkadot JS Apps</a>. This is a great way to play with your contract and explore it. Another way would be to clone the Parity’s <a href=\"https://github.com/substrate-developer-hub/substrate-front-end-template\">Substrate Front End Template</a> from GitHub, run it, and adapt to your needs. We will however connect from NestJS. It would enable us to wrap the calls to the blockchain with some user-friendly stuff as well as store any additional descriptive information, which we shouldn’t put on-chain.</p>\n<p>Check our previous blog post describing in detail how to <a href=\"https://brightinventions.pl/blog/connect-to-substrate-nestjs/\">connect to a Substrate node</a> and query it for some basic data. Here is a shortcut.</p>\n<p>First of all, we need to create a new NestJS project. If you do not have the Nest CLI installed you can check the docs <a href=\"https://docs.nestjs.com/cli/overview\">here</a> or just install it with a following command:</p>\n<pre><code class=\"language-shell\">npm install -g @nestjs/cli\n</code></pre>\n<p>Now you can create a new project.</p>\n<pre><code class=\"language-shell\">nest new substrate-nests\n</code></pre>\n<p>Change directory and run the app.</p>\n<pre><code class=\"language-shell\">cd substrate-nests\n</code></pre>\n<pre><code class=\"language-shell\">yarn start:dev\n</code></pre>\n<p>Add Polkadot api library to interact with the Substrate node:</p>\n<pre><code class=\"language-shell\">yarn add @polkadot/api\n</code></pre>\n<p>For the lib to work correctly, add the following to your <code>tsconfig.json</code>.</p>\n<pre><code class=\"language-javascript\">\"esModuleInterop\": true\n</code></pre>\n<p>Add Polkadot <code>api-contract</code> library to interact with the Contracts Pallet.</p>\n<pre><code class=\"language-shell\">yarn add @polkadot/api-contract\n</code></pre>\n<p>It is also possible that you will need another version of Node.js. You can use <a href=\"https://github.com/nvm-sh/nvm\">Node Version Manager</a> to manage different versions.</p>\n<h2>Connect to the node</h2>\n<p>We will add a <code>ContractService</code> to interact with the smart contract. This service will implement the <code>OnModuleInit</code> interface.</p>\n<pre><code class=\"language-javascript\">@Injectable()\nexport class ContractService implements OnModuleInit {\n    async onModuleInit() {\n    }\n}\n</code></pre>\n<p>In the <code>onModuleInit()</code> function we will create the connections to the api. First of all we need to create a WebSocket Provider with the url of our node. As we are using a local node it simply is <code>localhost</code>.</p>\n<pre><code class=\"language-javascript\">const SUBSTRATE_URL = 'ws://127.0.0.1:9944';\n</code></pre>\n<pre><code class=\"language-javascript\">const wsProvider = new WsProvider(SUBSTRATE_URL);\n</code></pre>\n<p>Next, we will create the <code>ApiPromise</code> object using the web socket provider. We need to declare a class scoped variable:</p>\n<pre><code class=\"language-javascript\">private api: ApiPromise;\n</code></pre>\n<p>We can instantiate it in the <code>onModuleInit</code> function:</p>\n<pre><code class=\"language-javascript\">this.api = await ApiPromise.create({\n        provider: wsProvider,\n        types: {\n        \"Address\": \"AccountId\",\n        \"LookupSource\": \"AccountId\"\n      }\n\n    });\n</code></pre>\n<p>We will now create a <code>PromiseContract</code> object from the <code>api-contract</code> library. This object is tightly connected with the contract we have created so we need some more information about it. We need the contract address. To get it, visit <a href=\"https://polkadot.js.org/apps\">Polkadot JS Apps</a>. Select <em>Developer -> Contracts</em> from the main menu, then select the <em>Contracts</em> tab. Clicking on the image next to the contract name (here it is ERC20.WASM (INSTANCE)) will copy the contract’s address to clipboard.</p>\n<p><img src=\"/images/screenshot-2020-09-01-at-20.35.53.png\"></p>\n<p>We can put it in a constant:</p>\n<pre><code class=\"language-javascript\">const ERC20 = '5DhP1rd5AEZCeZY77Zttbt293rX6tX4QnqEajEMd5i1QKsnB'\n</code></pre>\n<p>Now we need to create an <code>Abi</code> object which includes the smart contract’s definitions. Copy the <code>metadata.json</code> file generated in the previous step (deploying the smart contract) into the <code>src</code> directory and import it:</p>\n<pre><code class=\"language-javascript\">import metadata from \"./metadata.json\";\n</code></pre>\n<p>Add a property to your <code>tsconfig.json</code> file to enable importing JSON files.</p>\n<pre><code class=\"language-javascript\">\"resolveJsonModule\": true,\n</code></pre>\n<p>Declare class variables:</p>\n<pre><code class=\"language-javascript\">private abi: Abi;\nprivate apiContract: PromiseContract;\n</code></pre>\n<p>Instantiate the objects:</p>\n<pre><code class=\"language-javascript\">const abiJSONobj = (&#x3C;any>metadata);\nthis.abi = new Abi(this.api.registry, abiJSONobj);\nthis.apiContract = new PromiseContract(this.api, this.abi, ERC20);\n</code></pre>\n<p>We can also wait until we are connected to the node.</p>\n<pre><code class=\"language-javascript\">await this.api.isReady;\n</code></pre>\n<p>What we have done so far should look somehow like the following:</p>\n<pre><code class=\"language-javascript\">// src/contract.service.ts\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ApiPromise, WsProvider } from '@polkadot/api';\nimport { Abi, PromiseContract } from '@polkadot/api-contract';\nimport metadata from \"./metadata.json\";\n \nconst SUBSTRATE_URL = 'ws://127.0.0.1:9944'\nconst ERC20 = '5DhP1rd5AEZCeZY77Zttbt293rX6tX4QnqEajEMd5i1QKsnB'\n \n@Injectable()\nexport class ContractService implements OnModuleInit {\n  private api: ApiPromise;\n  private abi: Abi;\n  private apiContract: PromiseContract;\n \n  async onModuleInit() {\n    Logger.log('Connecting to substrate chain...');\n    const wsProvider = new WsProvider(SUBSTRATE_URL);\n    this.api = await ApiPromise.create({\n      provider: wsProvider,\n      types: {\n        \"Address\": \"AccountId\",\n        \"LookupSource\": \"AccountId\"\n      }\n \n    });\n \n    const abiJSONobj = (&#x3C;any>metadata);\n    this.abi = new Abi(this.api.registry, abiJSONobj);\n    this.apiContract = new PromiseContract(this.api, this.abi, ERC20);\n \n    await this.api.isReady;\n  }\n}\n</code></pre>\n<h2>Total supply</h2>\n<p>We can now query the node for the total supply of our token. We are going to use the <code>call()</code> function from the <code>PromiseContract</code> class. </p>\n<p>Let’s take a look at the definition of the function:</p>\n<pre><code class=\"language-javascript\">call(as: 'rpc', message: string, value: BN | number, gasLimit: BN | number, ...params: any[]): ContractCall&#x3C;ApiType, 'rpc'>;\ncall(as: 'tx', message: string, value: BN | number, gasLimit: BN | number, ...params: any[]): ContractCall&#x3C;ApiType, 'tx'>;\n</code></pre>\n<ul>\n<li><code>as</code> - <code>tx</code> string value is used for a transaction call. For a read-only request, we can use <code>rpc</code>. </li>\n<li><code>message</code> - name of the smart contract’s function we want to call.</li>\n<li><code>value</code> - you can transfer some basic units alongside sending a transaction, but we will not use it, so the value will always be 0.</li>\n<li><code>gasLimit</code> - the maximum value of gas this call can charge your account. Every transaction call of a smart contract is in general charged with a gas fee for the computational resources used. With an RPC call, we still need to provide a valid gas limit value, but as nothing is actually stored on-chain, you will not be charged. Previously, you were to define a conversion rate between the gas price and the Substrate currency for the Contracts Pallet (which is also the case for Ethereum smart contracts). Now it is fixed: <code>1 gas = 1 weight = 1 ps</code>. <code>weight</code> is a unit used in Substrate Runtime development to set the fee for calling the functions and <code>ps</code> is one picosecond of execution on the reference system.</li>\n<li><code>params</code> - parameters to pass to the smart contract’s function we want to call.</li>\n</ul>\n<p>The <code>call()</code> function creates a <code>ContractCall</code>, which exposes a <code>send()</code> function:</p>\n<pre><code class=\"language-javascript\">send(account: IKeyringPair | string | AccountId | Address): ContractCallResultSubscription&#x3C;ApiType, CallType>;\n</code></pre>\n<p>We need to specify the account, which is going to call a function. For the readonly calls it is enough to pass the account’s address. To make things simple, we will use Alice predefined account:</p>\n<pre><code class=\"language-javascript\">const ALICE = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'\n</code></pre>\n<p>In the code snippet below we call the <code>totalSupply</code> function (which does not have any parameters so we can omit the <code>params</code>) and send it as Alice.</p>\n<pre><code class=\"language-javascript\">async totalSupply() {\n    const result: ContractCallOutcome = await this.apiContract.call('rpc', 'totalSupply', 0, 1000000000000)\n      .send(ALICE) as ContractCallOutcome\n    return result.output.toString()\n  }\n</code></pre>\n<p>An important note on the gas limit value. When you were initializing the contract with Polkadot JS Apps, maximum gas limit of 1 000 000 was enough. Here we pass six more zeros. This is because under the hood Polkadot JS Apps multiplies the value of gas limit by 10^6.</p>\n<p>Now we can create a controller to expose the function. In the <code>src</code> directory create a file <code>balances.controller.ts</code>. Set the controller route, inject <code>ContractService</code> and create a function <code>totalSupply</code> decorated with <code>@Get</code> which calls the <code>contractService.totalSupply()</code> function.</p>\n<pre><code class=\"language-javascript\">// src/balances.controller.ts\nimport { Controller, Get } from '@nestjs/common';\nimport { ContractService } from './contract.service';\n \n@Controller('balances')\nexport class BalancesController {\n  constructor(private readonly contractService: ContractService) {}\n \n  @Get()\n  async totalSupply(): Promise&#x3C;string> {\n    console.log('totalSupply')\n    const data = await this.contractService.totalSupply();\n    return `${data}`;\n  }\n}\n</code></pre>\n<p>Add the service and the controller to the app module.</p>\n<pre><code class=\"language-javascript\">// src/app.module.ts\nimport { Module } from '@nestjs/common';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { BalancesController } from './balances.controller';\nimport { ContractService } from './contract.service';\n \n@Module({\n  imports: [],\n  controllers: [AppController, BalancesController],\n  providers: [AppService, ContractService],\n})\nexport class AppModule {}\n</code></pre>\n<p>You can now check the result in a browser.</p>\n<p><img src=\"/images/erc20-substrate-nest-example/image4.png\"></p>\n<p>When I have deployed my smart contract through the Polkadot JS Apps, I set the init supply to 1 000 000. Each currency value is a decimal stored as an integer with a fixed and known number of decimal places (in Substrate Node Template it is 15 by default). Polkadot JS Apps wraps that for you in the input field, so that I have indeed initialized the contract with one million units. However, when querying the smart contract through the Polkadot JS Apps or using the api we always get the additional 15 decimal zeros.</p>\n<h2>Balance of an account</h2>\n<p>Another snippet shows how to call the <code>balanceOf</code> function. The only difference is that we need to pass the parameter to specify whose balance we are asking of.</p>\n<pre><code class=\"language-javascript\">async balanceOf(who: string) {\n    const result: ContractCallOutcome = await this.apiContract.call('rpc', 'balanceOf', 0, 1000000000000, [who])\n      .send(ALICE) as ContractCallOutcome\n    return result.output.toString()\n  }\n</code></pre>\n<p>And a corresponding function in the controller:</p>\n<pre><code class=\"language-javascript\">@Get(':id')\n  async balanceOf(@Param() params): Promise&#x3C;string> {\n    console.log('balanceof ' + params.id)\n    const data = await this.contractService.balanceOf(accounts[params.id]);\n    return `${data}`;\n  }\n</code></pre>\n<p>To easily interact with the api from a browser, we can create a list of the predefined account’s addresses:</p>\n<pre><code class=\"language-javascript\">const accounts = {\n  ALICE: '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',\n  BOB: '5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty',\n  CHARLIE: '5FLSigC9HGRKVhB9FiEo4Y3koPsNmBmLJbpXg2mp1hXcS59Y',\n  DAVE: '5DAAnrj7VHTznn2AWBemMuyBwZWs6FNFjdyVXUeYum3PTXFy',\n  EVE: '5HGjWAeFDfFCWPsjFQdVV2Msvz2XtMktvgocEZcCj68kUMaw',\n}\n</code></pre>\n<h2>Transfer</h2>\n<p>As we already know how to read data from our smart contract, it is time to make a transaction.\nTo sign a transaction alongside sending it, we need to pass a <code>KeyringPair</code> instead of the account's address. As we are in development mode, we will use the predefined Alice account again, so creating a <code>KeyringPair</code> is fairly simple:</p>\n<pre><code class=\"language-javascript\">const keyring = new Keyring({ type: 'sr25519' });\nthis.alice = keyring.addFromUri('//Alice', { name: 'Alice default' });\n</code></pre>\n<p>To get a deeper understanding of the keyring concept please visit <a href=\"https://polkadot.js.org/api/start/keyring.html\">Polkadot JS API reference</a>. </p>\n<p>There are two ways to call the <code>transfer</code> function. One would be to use the <code>apiContract.call()</code> function with the first parameter set to <code>tx</code>. </p>\n<pre><code class=\"language-javascript\">async transfer(to: string, value: number) {\n    const extrinsicHash: SubmittableResult = await this.apiContract.call('tx', 'transfer', 0, 1000000000000, to, value)\n      .send(this.alice) as SubmittableResult\n \n    return extrinsicHash.toString();\n  }\n</code></pre>\n<p>As a result of this function, we get the extrinsic hash. It is not the block hash, because the transaction was yet only submitted to the transaction query. The extrinsic hash alone is not unique over the chain, so we would prefer to know the block hash. <code>apiContract.call()</code> function does not expose a parameter to pass a callback function to observe the events. Therefore we will use a function from the basic Polkadot api this time.</p>\n<pre><code class=\"language-javascript\">call: AugmentedSubmittable&#x3C;(dest: LookupSource | Address | AccountId | AccountIndex | string | Uint8Array, value: Compact&#x3C;BalanceOf> | AnyNumber | Uint8Array, gasLimit: Compact&#x3C;Gas> | AnyNumber | Uint8Array, data: Bytes | string | Uint8Array) => SubmittableExtrinsic&#x3C;ApiType>>;\n</code></pre>\n<ul>\n<li><code>dest</code> - this is the address we want to communicate with. As we want to make a call to the smart contract, we will set it to the smart contract's address. </li>\n<li><code>value</code> - same as in <code>ApiContract.call()</code></li>\n<li><code>gasLimit</code> - same as in <code>ApiContract.call()</code></li>\n<li><code>data</code> - any data we want to put in the transaction, here it is the function call.</li>\n</ul>\n<pre><code class=\"language-javascript\">await this.api.tx.contracts.call(ERC20, 0, 1000000000000, this.abi.messages.transfer(to, value))\n.signAndSend(this.alice, (result: SubmittableResult) => { Logger.log(result) })\n</code></pre>\n<p>We submit to the result and log it. We will see three events logged: </p>\n<ul>\n<li>an event upon transaction creation</li>\n<li>an event with status <code>InBlock</code> and a block hash when the transaction is included in a block</li>\n<li>an event with status <code>Finalized</code> when the transaction is finalized.</li>\n</ul>\n<p>A finalized transaction does not mean a successful transaction. It only means that the processing of a transaction has finished. We can check in <a href=\"https://polkadot.js.org/apps\">Polkadot JS Apps</a> if the transaction is successful. Go to <em>Network</em> -> <em>Explorer</em> page and paste the transaction hash in the upper left corner input <code>block hash or number to query</code>.</p>\n<p><img src=\"/images/screenshot-2020-09-01-at-20.56.18.png\"></p>\n<p>You can explore the block details.</p>\n<p><img src=\"/images/screenshot-2020-09-01-at-20.57.29.png\"></p>\n<p>On the right side, you can see the events emitted by the smart contract. The last one says <code>ExtrinsicSuccess</code>, so we know the transaction was successful. You can try to submit a transaction with <code>gasLimit = 0</code>. Once the transaction is finalized, view its details. You can see the <code>ExtrinsicFailed</code> event.</p>\n<p><img src=\"/images/screenshot-2020-09-01-at-20.58.38.png\"></p>\n<p>The <code>contract.service.ts</code> file should look like this now:</p>\n<pre><code class=\"language-javascript\">// src/contract.service.ts\nimport { Injectable, Logger, OnModuleInit } from '@nestjs/common';\nimport { ApiPromise, Keyring, SubmittableResult, WsProvider } from '@polkadot/api';\nimport { Abi, PromiseContract } from '@polkadot/api-contract';\nimport { ContractCallOutcome } from '@polkadot/api-contract/types';\nimport { KeyringPair } from '@polkadot/keyring/types';\nimport metadata from \"./metadata.json\";\n \nconst SUBSTRATE_URL = 'ws://127.0.0.1:9944'\nconst ERC20 = '5DhP1rd5AEZCeZY77Zttbt293rX6tX4QnqEajEMd5i1QKsnB'\nconst ALICE = '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY'\n \n@Injectable()\nexport class ContractService implements OnModuleInit {\n  private api: ApiPromise;\n  private abi: Abi;\n  private alice: KeyringPair;\n  private apiContract: PromiseContract;\n \n  async onModuleInit() {\n    Logger.log('Connecting to substrate chain...');\n    const wsProvider = new WsProvider(SUBSTRATE_URL);\n    this.api = await ApiPromise.create({\n      provider: wsProvider,\n      types: {\n        \"Address\": \"AccountId\",\n        \"LookupSource\": \"AccountId\"\n      }\n    });\n \n    const abiJSONobj = (&#x3C;any>metadata);\n    this.abi = new Abi(this.api.registry, abiJSONobj);\n    this.apiContract = new PromiseContract(this.api, this.abi, ERC20);\n \n    await this.api.isReady;\n \n    const keyring = new Keyring({ type: 'sr25519' });\n    this.alice = keyring.addFromUri('//Alice', { name: 'Alice default' });\n  }\n \n  async transfer(to: string, value: number) {\n    await this.api.tx.contracts.call(ERC20, 0, 1000000000000, this.abi.messages.transfer(to, value))\n      .signAndSend(this.alice, (result: SubmittableResult) => { Logger.log(result) })\n  }\n \n \n  async balanceOf(who: string) {\n    const result: ContractCallOutcome = await this.apiContract.call('rpc', 'balanceOf', 0, 1000000000000, who)\n      .send(ALICE) as ContractCallOutcome\n    return result.output.toString()\n  }\n \n  async totalSupply() {\n    this.api.rpc.contracts.call\n    const result: ContractCallOutcome = await this.apiContract.call('rpc', 'totalSupply', 0, 1000000000000)\n      .send(ALICE) as ContractCallOutcome\n    return result.output.toString()\n  }\n \n}\n</code></pre>\n<p>We can now add a transfer function to the controller and an interface for the request body.</p>\n<pre><code class=\"language-javascript\">interface TransferDto {\n  to: string\n  value: number\n}\n</code></pre>\n<pre><code class=\"language-javascript\">@Put()\n@HttpCode(202)\nasync transfer(@Body() transferDto: TransferDto){\n  await this.contractService.transfer(accounts[transferDto.to], transferDto.value);\n}\n</code></pre>\n<p>The response code is <code>202</code> as the transaction was only accepted to proceed.</p>\n<p>The <code>balances.controller.ts</code> file should look like this now:</p>\n<pre><code class=\"language-javascript\">// src/balances.controller.ts\nimport { Body, Controller, Get, HttpCode, Param, Put } from '@nestjs/common';\nimport { ContractService } from './contract.service';\n \n// accounts list to easily interact with the API\nconst accounts = {\n  ALICE: '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',\n  BOB: '5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty',\n  CHARLIE: '5FLSigC9HGRKVhB9FiEo4Y3koPsNmBmLJbpXg2mp1hXcS59Y',\n  DAVE: '5DAAnrj7VHTznn2AWBemMuyBwZWs6FNFjdyVXUeYum3PTXFy',\n  EVE: '5HGjWAeFDfFCWPsjFQdVV2Msvz2XtMktvgocEZcCj68kUMaw',\n}\n \ninterface TransferDto {\n  to: string\n  value: number\n}\n \n@Controller('balances')\nexport class BalancesController {\n  constructor(private readonly contractService: ContractService) { }\n \n  @Get()\n  async totalSupply(): Promise&#x3C;string> {\n    const data = await this.contractService.totalSupply();\n    return `${data}`;\n  }\n \n  @Get(':id')\n  async balanceOf(@Param() params): Promise&#x3C;string> {\n    const data = await this.contractService.balanceOf(accounts[params.id]);\n    return `${data}`;\n  }\n \n  @Put()\n  @HttpCode(202)\n  async transfer(@Body() transferDto: TransferDto) {\n    await this.contractService.transfer(accounts[transferDto.to], transferDto.value);\n  }\n}\n</code></pre>\n<p>Let's now do some transfers. We can use <a href=\"https://www.postman.com/\">Postman</a> for this.</p>\n<p>We will transfer some units to Bob. As we sign all transactions as Alice, she will be the sender. We need to create a <code>PUT</code> request at <code>http://localhost:3000/balances</code> url and pass two body parameters: <code>to: BOB</code> and <code>value: 1000000000000000000</code> (again, we have the 15 decimal zeros here, so we actually transfer 1 000 units).</p>\n<p><img src=\"/images/erc20-substrate-nest-example/image8.png\"></p>\n<p>Now let's check again the balances (I omit the decimal zeros here so that the numbers are more readable):</p>\n<ul>\n<li>total balance (<a href=\"http://localhost:3000/balances\">http://localhost:3000/balances</a>)[<a href=\"http://localhost:3000/balances\">http://localhost:3000/balances</a>] - should not change and still be 1 000 000</li>\n<li>Alice's balance (<a href=\"http://localhost:3000/balances/ALICE\">http://localhost:3000/balances/ALICE</a>)[<a href=\"http://localhost:3000/balances/ALICE\">http://localhost:3000/balances/ALICE</a>] - should be reduced by 1 000 to 999000</li>\n<li>Bob's balance (<a href=\"http://localhost:3000/balances/BOB\">http://localhost:3000/balances/BOB</a>)[<a href=\"http://localhost:3000/balances/BOB\">http://localhost:3000/balances/BOB</a>] - should be 1 000.</li>\n</ul>\n<h2>Approval</h2>\n<p>We can now add the functions needed for the approval feature. There are two transactions to be handled: approving another account to make transfers for us up to a fixed amount and transferring on behalf. We can also query the chain for the allowances. Let's add three functions to the <code>ContractService</code> class.</p>\n<pre><code class=\"language-javascript\">async allowance(owner: string, spender: string) {\n  const result: ContractCallOutcome = await this.apiContract.call('rpc', 'allowance', 0, 1000000000000, owner, spender)\n    .send(ALICE) as ContractCallOutcome\n  return result.output.toString()\n}\n\nasync approve(spender: string, value: number) {\n  await this.api.tx.contracts.call(ERC20, 0, 1000000000000, this.abi.messages.approve(spender, value))\n    .signAndSend(this.alice, (result: SubmittableResult) => { Logger.log(result) })\n}\n\nasync transferFrom(from: string, to: string, value: number) {\n  await this.api.tx.contracts.call(ERC20, 0, 1000000000000, this.abi.messages.transferFrom(from, to, value))\n    .signAndSend(this.alice, (result: SubmittableResult) => { Logger.log(result) })\n}\n</code></pre>\n<p>To expose the allowance feature we can create another controller.</p>\n<pre><code class=\"language-javascript\">// src/allowances.controller.ts\nimport { Body, Controller, Get, HttpCode, Post, Query } from '@nestjs/common';\nimport { ContractService } from './contract.service';\n\n// accounts list to easily interact with the API\nconst accounts = {\n  ALICE: '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY',\n  BOB: '5FHneW46xGXgs5mUiveU4sbTyGBzmstUspZC92UhjJM694ty',\n  CHARLIE: '5FLSigC9HGRKVhB9FiEo4Y3koPsNmBmLJbpXg2mp1hXcS59Y',\n  DAVE: '5DAAnrj7VHTznn2AWBemMuyBwZWs6FNFjdyVXUeYum3PTXFy',\n  EVE: '5HGjWAeFDfFCWPsjFQdVV2Msvz2XtMktvgocEZcCj68kUMaw',\n}\n\ninterface AllowanceDto {\n  spender: string,\n  value: number,\n}\n\n@Controller('allowances')\nexport class AllowancesController {\n  constructor(private readonly contractService: ContractService) { }\n\n  @Get()\n  async allowance(@Query('owner') owner, @Query('spender') spender): Promise&#x3C;string> {\n    const data = await this.contractService.allowance(accounts[owner], accounts[spender]);\n    return `${data}`;\n  }\n\n  @Post()\n  @HttpCode(202)\n  async approve(@Body() allowanceDto: AllowanceDto) {\n    console.log(allowanceDto);\n    await this.contractService.approve(accounts[allowanceDto.spender], allowanceDto.value);\n  }\n}\n</code></pre>\n<p>To handle transferring from another account, we can change the <code>transfer()</code> function of the <code>BalancesController</code> and the <code>TransferDto</code> interface.</p>\n<pre><code class=\"language-javascript\">interface TransferDto {\n  from?: string\n  to: string\n  value: number\n}\n</code></pre>\n<pre><code class=\"language-javascript\">  @Put()\n  @HttpCode(202)\n  async transfer(@Body() transferDto: TransferDto) {\n    if (transferDto.from !== undefined) {\n      await this.contractService.transferFrom(accounts[transferDto.from], accounts[transferDto.to], transferDto.value);\n    }\n    else {\n      await this.contractService.transfer(accounts[transferDto.to], transferDto.value);\n    }\n  }\n</code></pre>\n<p>We would like to allow Alice to send 200 units on behalf of Bob. Such a transaction should be signed by Bob, but our app does not enable choosing a signer. Let's then switch to <a href=\"https://polkadot.js.org/apps\">Polkadot JS Apps</a>. Go to <em>Developer</em> -> <em>Contracts</em> page, choose <em>Contracts</em> tab and click the <em>execute</em> button on the contract. Change the account, so that we will call the contract functions from Bob's account. Choose <code>approve</code> as a message to send. Choose Alice as a spender and set the value to 200 (no decimal zeros here!). Click the <em>Call</em> button, sign and submit the transaction (make sure that Bob is the signer).</p>\n<p><img src=\"/images/erc20-substrate-nest-example/image10.png\"></p>\n<p>We can check the allowance in the browser <a href=\"http://localhost:3000/allowances?owner=BOB&#x26;spender=ALICE\">http://localhost:3000/allowances?owner=BOB&#x26;spender=ALICE</a> to be 200.</p>\n<p>Now let's go back to Postman and let Alice make a transfer from Bob's to Charlie's wallet. Remember to add the decimal zeros and to transfer less than the approved value. I decided to transfer 110.</p>\n<p><img src=\"/images/erc20-substrate-nest-example/image9.png\"></p>\n<p>We can now confirm that:</p>\n<ul>\n<li><a href=\"http://localhost:3000/balances/CHARLIE\">http://localhost:3000/balances/CHARLIE</a> - Charlie's balance is 110</li>\n<li><a href=\"http://localhost:3000/balances/ALICE\">http://localhost:3000/balances/ALICE</a> - Alice's balance is still 999000</li>\n<li><a href=\"http://localhost:3000/balances/BOB\">http://localhost:3000/balances/BOB</a> - Bob's balance is reduced by 110 and now it's 890</li>\n<li><a href=\"http://localhost:3000/allowances?owner=BOB&#x26;spender=ALICE\">http://localhost:3000/allowances?owner=BOB&#x26;spender=ALICE</a> - the approval is also reduced by 110 and now it's 90.</li>\n</ul>\n<p>We can also use our api to allow Bob to transfer 100 units on behalf of Alice. We can create a POST request in Postman at <code>http://localhost:3000/allowances</code> url and pass two body parameters: <code>sender: BOB</code> and <code>value: 100000000000000000</code> (again, we have the 15 decimal zeros).</p>\n<p><img src=\"/images/erc20-substrate-nest-example/image11.png\"></p>\n<p>We can check the allowance in the browser <a href=\"http://localhost:3000/allowances?owner=ALICE&#x26;spender=BOB\">http://localhost:3000/allowances?owner=ALICE&#x26;spender=BOB</a> to be 100. </p>\n<p>We can now let Bob make a transfer of 30 units from Alice's to Dave's wallet using the Polkadot JS Apps:</p>\n<p><img src=\"/images/erc20-substrate-nest-example/image12.png\"></p>\n<p>We can now confirm that:</p>\n<ul>\n<li><a href=\"http://localhost:3000/balances/DAVE\">http://localhost:3000/balances/DAVE</a> - Dave's balance is 30</li>\n<li><a href=\"http://localhost:3000/balances/ALICE\">http://localhost:3000/balances/ALICE</a> - Alice's balance is reduced by 30 and it's 998970</li>\n<li><a href=\"http://localhost:3000/balances/BOB\">http://localhost:3000/balances/BOB</a> - Bob's balance is is still 890</li>\n<li><a href=\"http://localhost:3000/allowances?owner=ALICE&#x26;spender=BOB\">http://localhost:3000/allowances?owner=ALICE&#x26;spender=BOB</a> - the approval is also reduced by 30 and now it's 70.</li>\n</ul>\n<h2>Summary</h2>\n<p>We have run a local Substrate node with the Contracts Pallet added. We have implemented an ERC20 token smart contract and deployed it to the Substrate node. Finally, we have created a simple NestJS app to interact with the smart contract and tested it.</p>\n<h2>What's next?</h2>\n<p>In the next part of this tutorial we will:</p>\n<ul>\n<li>look through an ERC20 token implementation in Substrate Runtime and interact with it from NestJS.</li>\n</ul>","excerpt":"In this blog post I will guide you through the process of implementing an ERC20 token with use of a smart contract on a Substrate node and…","frontmatter":{"slug":null,"title":"Develop your own cryptocurrency with Substrate PART 1","description":null,"author":"agnieszka","tags":["substrate","parity","blockchain","nest","nestjs","smart contract","erc20","cryptocurrency"],"date":"2020-09-01T18:25:43.483Z","image":"/images/cryptocurrency_with_substrate1-–-2.png"},"timeToRead":21,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-07-22-erc20-substrate-nest-example.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-07-22-erc20-substrate-nest-example.md"}}}