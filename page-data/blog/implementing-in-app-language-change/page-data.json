{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/implementing-in-app-language-change","result":{"data":{"markdownRemark":{"html":"<p>Android resolves language- and culture-specific resources based on the system locale setting. This is a desired behavior that makes perfect sense. Despite it's officially not encouraged you may still need to write an app that allows the user to change its language without leaving it. In this article I will show you one of the possible ways to implement such feature.</p>\n<p><img src=\"/images/implementing-in-app-language-change/communication.jpg\" alt=\"Communication\">{: .center-image}</p>\n<h1>The big picture</h1>\n<p>Before I start with the code, let me explain how this whole mechanism will work.</p>\n<p>I'm going to translate all the strings visible on the current application screen during the lifecycle callbacks (e.g. <code>Activity.onResume()</code> and <code>Fragment.onResume()</code>). This approach is easy to implement and understand and it currently covers all my needs. I won't try to force the app to translate itself magically. This means some overhead in the code for re-initializing all the texts and views which need to be translated.</p>\n<p>The following diagram illustrates the flow of getting a localized string by Activity:</p>\n<p><img src=\"/images/implementing-in-app-language-change/localization.png\" alt=\"Getting a string\">{: .center-image}</p>\n<p>The flow involves <code>StringLocalization</code> object which has a map containing all the available <code>Resources</code> and that uses <code>AppSettings</code> to get current language that was set by the user.</p>\n<h1>Storing user preferences</h1>\n<p>To keep the chosen language between app restarts, we will store the preference in <code>SharedPreferences</code>. But first, let's declare an enum class to represent our languages and an object with locale codes to avoid hardcoding values in various places.</p>\n<pre><code class=\"language-kotlin\">object LocaleCodes {\n    const val ENGLISH = \"en\"\n    const val POLISH = \"pl\"\n    const val GERMAN = \"de\"\n}\n\nenum class Language(val locale: Locale) {\n    English(Locale(LocaleCodes.ENGLISH)),\n    German(Locale(LocaleCodes.GERMAN)),\n    Polish(Locale(LocaleCodes.POLISH));\n\n    companion object {\n        val DEFAULT = English\n\n        fun fromLocale(locale: Locale): Language =\n                values().firstOrNull { it.locale.language == locale.language } ?: DEFAULT\n    }\n}\n</code></pre>\n<p>Additionally, the enum class has a static <code>DEFAULT</code> value and <code>fromLocale</code> function which we will use later on.</p>\n<p>Now, let's implement a class for storing user preferences:</p>\n<pre><code class=\"language-kotlin\">interface AppSettings {\n    var currentLanguage: Language\n}\n\nclass SharedPrefAppSettings(\n    private val sharedPref: SharedPreferences,\n    private val androidConfiguration: Configuration\n) : AppSettings {\n\n    private var currentLanguageCache: Language? = null\n\n    override var currentLanguage: Language\n        get() {\n            val cachedValue = currentLanguageCache\n\n            return if (cachedValue == null) {\n                val storedValue = sharedPref.getString(APP_LANGUAGE_KEY, \"\")\n                val storedLanguage = try {\n                    Language.valueOf(storedValue)\n                } catch (ex: Exception) {\n                    null\n                }\n\n                val language = storedLanguage ?: getDefaultLanguage()\n\n                currentLanguage = language\n\n                language\n            } else cachedValue\n        }\n        set(value) {\n            currentLanguageCache = value\n            sharedPref.edit().putString(APP_LANGUAGE_KEY, value.toString()).apply()\n        }\n\n    private fun getDefaultLanguage(): Language {\n        val locale = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n            androidConfiguration.locales[0]\n        } else {\n            androidConfiguration.locale\n        }\n\n        return Language.fromLocale(locale)\n    }\n\n    companion object {\n        private const val APP_LANGUAGE_KEY = \"app_language\"\n    }\n}\n</code></pre>\n<p>I don't like to say the code is self-explanatory so let me tell you what's going on.\nStoring the chosen language is quite simple: we cache its value in <code>currentLanguageCache</code> and store it in <code>SharedPreferences</code> at <code>APP_LANGUAGE_KEY</code>.\nGetting the language is a bit more complicated, especially when the app is launched for the first time:</p>\n<ul>\n<li>we use the cached value if it's present</li>\n<li>if we don't have it yet, we read from <code>SharedPreferences</code></li>\n<li>then we try to get our enum from that value</li>\n<li>\n<p>if we can't get it properly (because there was no value in <code>SharedPrefereces</code> or we read something that can't be represented by our enum), we get a default language using <code>getDefaultLanguage()</code></p>\n<ul>\n<li>we read the <code>Locale</code> the app was started with from <code>Configuration</code> (it comes from <code>context.resources.configuration</code>)</li>\n<li>then we try to get our enum value from that <code>Locale</code></li>\n<li>in worst case scenario we end up with the <code>Language.DEFAULT</code> value</li>\n</ul>\n</li>\n<li>we cache the resulting language by calling the setter: <code>currentLanguage = language</code></li>\n</ul>\n<p>We will use Dagger to inject <code>SharedPrefAppSettings</code> implementation of the <code>AppSettings</code> interface thanks to this simple module:</p>\n<pre><code class=\"language-kotlin\">@Module\nclass AppSettingsModule {\n    @Provides\n    @Singleton\n    fun provideAppSettings(context: Context, configuration: Configuration): AppSettings =\n            SharedPrefAppSettings(PreferenceManager.getDefaultSharedPreferences(context), configuration)\n}\n</code></pre>\n<h1>Initializing locale-specific resources</h1>\n<p>In order to access resources defined for a specific locale, we need to do the following:</p>\n<ul>\n<li>make a new copy of your current resources <code>Configuration</code></li>\n<li>set the desired locale with <code>setLocale()</code></li>\n<li>create a configuration context with <code>context.createConfigurationContext()</code></li>\n<li>get resources from the new context</li>\n</ul>\n<p>so the code can look like this:</p>\n<pre><code class=\"language-kotlin\">val conf = Configuration(context.resources.configuration)\nconf.setLocale(Locale(LocaleCodes.ENGLISH))\nval localizedContext = context.createConfigurationContext(conf)\nval localizedResources = localizedContext.resources\n</code></pre>\n<p>Now we can generate a map of resources for each language. As usual, there are plenty of ways you can do it. In this example we use Dagger <a href=\"https://google.github.io/dagger/multibindings#map-multibindings\">map multibindings</a>.</p>\n<p>First, let's define a <code>LanguageKey</code> annotation so that we can have a map with <code>Language</code> enum keys:</p>\n<pre><code class=\"language-kotlin\">@MustBeDocumented\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\n@MapKey\nannotation class LanguageKey(val value: Language)\n</code></pre>\n<p>Next, we use it to generate multiple <code>Resources</code>:</p>\n<pre><code class=\"language-kotlin\">@Module\nclass LocalizationModule {\n\n    @Provides\n    @IntoMap\n    @LanguageKey(Language.English)\n    fun providesEnglishResources(context: Context): Resources =\n        getLocalizedResources(context, Language.English.locale)\n\n    @Provides\n    @IntoMap\n    @LanguageKey(Language.Polish)\n    fun providesPolishResources(context: Context): Resources =\n        getLocalizedResources(context, Language.Polish.locale)\n\n    @Provides\n    @IntoMap\n    @LanguageKey(Language.German)\n    fun providesGermanResources(context: Context): Resources =\n        getLocalizedResources(context, Language.German.locale)\n\n    private fun getLocalizedResources(context: Context, locale: Locale): Resources {\n        val conf = Configuration(context.resources.configuration)\n        conf.setLocale(locale)\n        val localizedContext = context.createConfigurationContext(conf)\n        return localizedContext.resources\n    }\n}\n</code></pre>\n<p>And voila, we can now inject <code>Map&#x3C;Language, Resources></code> with Dagger.</p>\n<h1>Providing string resources</h1>\n<p>Finally, it's time to add a helper class that will provide string resources from the generated map.</p>\n<pre><code class=\"language-kotlin\">@Singleton\nclass StringsLocalization @Inject constructor(\n        private val settings: AppSettings,\n        private val resMap: Map&#x3C;Language, @JvmSuppressWildcards Resources>\n) {\n\n    private val log = logger\n\n    fun getString(@StringRes stringId: Int): String = resMap\n            .getOrElse(settings.currentLanguage, this::getFallbackResources)\n            .getString(stringId)\n\n    private fun getFallbackResources(): Resources {\n        val defaultLanguage =\n                if (Language.DEFAULT in resMap) Language.DEFAULT\n                else resMap.keys.firstOrNull()\n\n        if (defaultLanguage != null) {\n            log.error(\"Current language resources not found. Fallback to: {}\", defaultLanguage)\n            settings.currentLanguage = defaultLanguage\n\n            return resMap[defaultLanguage]!!\n        } else {\n            throw ResourcesNotFoundException(\"String resources not found\")\n        }\n    }\n}\n\nclass ResourcesNotFoundException(message: String) : RuntimeException(message)\n</code></pre>\n<p>Both <code>AppSettings</code> (i.e. <code>SharedPrefAppSettings</code>) and the resources map will be injected by Dagger.\nYou can see the <code>getString()</code> method that takes string resource ID, just like the regular <code>Activity.getString()</code> method. It will get the language from <code>AppSettings</code> and use it to retrieve the proper <code>Resources</code> from the map. If the map doesn't contain anything at that language key for some reason, we will use <code>getFallbackResources()</code> method as a last resort before failing to provide a string.</p>\n<h1>Making it work</h1>\n<p>All we have to do now is to inject <code>StringsLocalization</code> object into the Activities and Fragments and use it to translate whatever we need.\nBut first, let's write a helper interface to make this task less boilerplate:</p>\n<pre><code class=\"language-kotlin\">interface HasStringsLocalization {\n    val stringsLocalization: StringsLocalization\n}\n\nfun HasStringsLocalization.getLocalizedString(@StringRes stringId: Int): String =\n        stringsLocalization.getString(stringId)\n</code></pre>\n<p>So now we can access strings with <code>getLocalizedString</code> easily like this:</p>\n<pre><code class=\"language-kotlin\">class WelcomeActivity : AppCompatActivity(), HasStringsLocalization {\n\n    @Inject\n    override lateinit var stringsLocalization: StringsLocalization\n\n    override fun onResume() {\n        super.onResume()\n        setTranslatedTexts()\n    }\n\n    private fun setTranslatedTexts() {\n        welcomeText.text = getLocalizedString(R.string.WELCOME)\n        // and more...\n    }\n}\n</code></pre>\n<p><em>Side note: I skipped some code here to make the example shorter and more readable. The full implementation could involve some kind of injection with Dagger, layout inflation, etc.</em></p>","excerpt":"Android resolves language- and culture-specific resources based on the system locale setting. This is a desired behavior that makes perfect…","frontmatter":{"slug":null,"title":"Implementing in-app language change","description":null,"author":"azabost","tags":["android","java","kotlin","language","dagger"],"date":"2018-02-14T23:00:00.000Z","image":"/images/implementing-in-app-language-change/communication.jpg"},"timeToRead":6,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-15-implementing-in-app-language-change.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-02-15-implementing-in-app-language-change.md"}}}