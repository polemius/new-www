{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/clear-database-in-spring-boot-tests","result":{"data":{"markdownRemark":{"html":"<p>Nowadays using a production like database in <em>unit</em><sup><a href=\"#sup-1\">1</a></sup> tests is a common practice. Calling a real database can increase our confidence that a tested code actually works. Having said that a database, by its very nature, brings external state into a test that will affect its behavior, hence we need to pay special attention to prepare the test execution. There are couple of ways to handle the database state in tests and I'm going to describe an approach I like most.</p>\n<p><img src=\"/images/clear-database-in-spring-boot-tests/disk.jpg\" alt=\"Database\">{: .center-image}</p>\n<h1>Problems with Spring Boot Transactional tests</h1>\n<p>Spring Boot offers many helpers to make testing application easier. Among many you can use a <a href=\"https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test\"><code>@DataJpaTest</code></a> which by default will configure an in-memory embedded database. You can use a production type database in tests by adding <code>@AutoConfigureTestDatabase(replace=Replace.NONE)</code> like so:</p>\n<pre><code class=\"language-java\">@RunWith(SpringRunner.class)\n@DataJpaTest\n@AutoConfigureTestDatabase(replace=Replace.NONE)\npublic class ExampleRepositoryTests {\n    // ...\n}\n</code></pre>\n<p>The <code>@DataJpaTest</code> uses <code>@Transactional</code> under the hood. A test is wrapped inside a transaction that is rolled back at the end. This means that when using e.g. Hibernate one needs to pay special attention to how the tested code is written. <a href=\"https://docs.spring.io/spring/docs/4.3.11.RELEASE/spring-framework-reference/htmlsingle/#testcontext-tx-enabling-transactions\">As shown in the Java example below</a>, a manual flush is indeed required:</p>\n<pre><code class=\"language-java\">@RunWith(SpringRunner.class)\n@ContextConfiguration(classes = TestConfig.class)\n@Transactional\npublic class HibernateUserRepositoryTests {\n    ...\n    @Test\n    public void createUser() {\n        // track initial state in test database:\n        final int count = countRowsInTable(\"user\");\n\n        User user = new User(...);\n        repository.save(user);\n\n        // Manual flush is required to avoid false positive in test\n        sessionFactory.getCurrentSession().flush();\n        assertNumUsers(count + 1);\n    }\n}\n</code></pre>\n<p>Using <code>@Transactional</code> annotation on tests is certainly easy but <strong>I still don't use it</strong> for the following reasons:</p>\n<ul>\n<li>The production code is using transactions with different scope.</li>\n<li>It is easy to forget about a flush and thus have false positive in test.</li>\n<li>On failure and when debugging it is hard to see what values were actually saved in db.</li>\n<li>It is much harder to write tests of production code that requires a transaction to be committed. </li>\n<li>The test code needs to be more tightly coupled to production code and <a href=\"http://blog.cleancoder.com/uncle-bob/2017/10/03/TestContravariance.html\">we all know that it hinders refactoring</a>.</li>\n</ul>\n<h1>Cleaning database with SQL</h1>\n<p>In tests involving a database I reset its state <strong>before each</strong> test using plain old SQL. This makes the test code less dependent on how a transaction is scoped inside production code. Furthermore, one can easily review the values saved <strong>after a test failure</strong>. It turns out it is easy to write a JUnit <code>@Rule</code> or <a href=\"http://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/extension/BeforeEachCallback.html\"><code>BeforeEachCallback</code></a> that will remove all rows from all tables. Moreover, we can do so without hard coding table names which would increase maintenance cost.</p>\n<p>Let's start with defining a <code>@Rule</code> in Kotlin in that will be called before each test:</p>\n<pre><code class=\"language-kotlin\">import org.junit.rules.ExternalResource\nimport org.springframework.stereotype.Component\nimport javax.sql.DataSource\n\n@Component\nclass DatabaseCleanerRule(private val dataSource: DataSource) : ExternalResource() {\n\n    override fun before() {\n        if (databaseCleaner == null) {\n            // Consider inspecting dataSource to check if we are connecting to test database\n            databaseCleaner = DatabaseCleaner(dataSource::getConnection)\n        }\n        databaseCleaner!!.reset()\n    }\n\n    companion object {\n        internal var databaseCleaner: DatabaseCleaner? = null\n    }\n}\n</code></pre>\n<p>Consider inspecting <code>dataSource</code> to check if we are about to connect to test database and <strong>not one used for development.</strong> It is very easy to use incorrect Spring Profile and wipe out your development data. Ask me how I know?</p>\n<p>We can use the <code>DatabaseCleanerRule</code> in a spring enabled test as any other JUnit rule e.g. <code>@Rule @Inject lateinit var cleanerRule: DatabaseCleanerRule</code>.</p>\n<p>Notice that we've delegated the actual important work to <code>DatabaseCleaner</code> class defined in Kotlin below. </p>\n<pre><code class=\"language-kotlin\">import com.practi.util.iterator\nimport org.slf4j.LoggerFactory\nimport java.sql.Connection\nimport java.sql.PreparedStatement\nimport java.sql.SQLException\n\nclass DatabaseCleaner(private val connectionProvider: () -> Connection) {\n    private val tablesToExclude = mutableSetOf&#x3C;String>()\n    private var tablesForClearing: List&#x3C;TableRef>? = null\n\n    fun excludeTables(vararg tableNames: String) {\n        tablesToExclude += tableNames.flatMap { listOf(it, it.toLowerCase()) }\n    }\n\n    fun reset() {\n        if (notPrepared) {\n            prepare()\n        }\n        executeReset()\n    }\n\n    private val notPrepared get() = tablesForClearing == null\n\n    private fun prepare() {\n        connectionProvider().use { connection ->\n            val metaData = connection.metaData\n            val tableRefs = metaData.getTables(connection.catalog, null, null, arrayOf(\"TABLE\")).use { tables ->\n                iterator(tables::next) { tables.getString(\"TABLE_NAME\") }\n                    .asSequence()\n                    .filterNot(tablesToExclude::contains)\n                    .map(::TableRef)\n                    .toList()\n            }\n\n            tablesForClearing = tableRefs\n\n            LOG.info(\"Prepared clean db command: {}\", tablesForClearing)\n        }\n    }\n\n    private fun executeReset() {\n        try {\n            connectionProvider().use { connection ->\n                val reset = buildClearStatement(connection)\n                val result = reset.executeBatch()\n                result\n            }\n        } catch (e: SQLException) {\n            val status = engineInnoDbStatus()\n            LOG.error(\"Failed to remove rows because {}. InnoDb status: {}\", e, status)\n            throw e\n        }\n    }\n\n    private fun engineInnoDbStatus(): String { ... }\n\n    private fun buildClearStatement(connection: Connection): PreparedStatement {\n        val reset = connection.prepareStatement(\"\")\n        reset.addBatch(\"SET FOREIGN_KEY_CHECKS = 0\")\n        tablesForClearing?.forEach { ref ->\n            reset.addBatch(\"DELETE FROM `${ref.name}`\")\n        }\n        reset.addBatch(\"SET FOREIGN_KEY_CHECKS = 1\")\n        return reset\n    }\n\n    data class TableRef(val name: String)\n\n    companion object {\n        private val LOG = LoggerFactory.getLogger(DatabaseCleaner::class.java)!!\n    }\n}\n</code></pre>\n<p>Notice that we've defined <code>tablesToExclude</code> set that allows us to omit certain tables. This comes in handy when you're using a database migration tool that stores its state inside some table(s).</p>\n<p><a href=\"https://docs.oracle.com/javase/7/docs/api/java/sql/DatabaseMetaData.html\">The JDBC metadata</a> allows us to introspect schema regardless of the database vendor. The <code>iterator</code> is a tiny Kotlin function that aids consuming iterator like objects:</p>\n<pre><code class=\"language-kotlin\">inline fun &#x3C;T> iterator(crossinline next: () -> Boolean, crossinline value: () -> T): AbstractIterator&#x3C;out T> = object : AbstractIterator&#x3C;T>() {\n    override fun computeNext() {\n        if (next()) {\n            setNext(value())\n        } else {\n            done()\n        }\n    }\n}\n</code></pre>\n<p>The <code>buildClearStatement</code> constructs a large query that <code>DELETE</code>s all rows from each relevant table. The example above uses MySQL where it is very easy to disable foreign key checks. This is important since foreign keys would prevent rows to be removed unless we paid special attention to the order of removal. A more generic example of how to deal with referential integrity when clearing a database can be found in the <a href=\"https://github.com/jbogard/Respawn\">Respawn project</a>.</p>\n<p>Last but not least, when a <code>SQLException</code> is thrown we log the exception accompanied with <a href=\"https://dev.mysql.com/doc/refman/5.7/en/show-engine.html\"><code>SHOW ENGINE INNODB STATUS</code></a>. The status information can hint us about failure reason e.g. another test process executing against the same database or a rogue, runaway thread that locks some rows. </p>\n<pre><code class=\"language-kotlin\">private fun engineInnoDbStatus(): String {\n    return connectionProvider().use { connection ->\n        connection.createStatement().executeQuery(\"SHOW ENGINE INNODB STATUS \").use {\n            iterator(it::next) { it.getString(\"Status\") }.asSequence().toList()\n        }.joinToString(System.lineSeparator())\n    }\n}\n</code></pre>\n<p>The above examples show that it is not hard to manually reset the database. I've found that using this approach makes my tests more trustworthy and less coupled to the underlying persistence layer. In fact, we can easily switch e.g. from JPA to <code>JdbcTemplate</code> in a performance critical code area without a need to change a test.</p>\n<p><em><sup>1</sup></em><a name=\"sup-1\"></a> Whether it is actually unit or integration test is a different topic.</p>","excerpt":"Nowadays using a production like database in unit1 tests is a common practice. Calling a real database can increase our confidence that a…","frontmatter":{"slug":null,"title":"How to clear database in Spring Boot tests?","description":null,"author":"piotr","tags":["tests","spring boot","database","kotlin"],"date":"2017-10-12T22:00:00.000Z","image":null},"timeToRead":6,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-10-13-clear-database-in-spring-boot-tests.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-10-13-clear-database-in-spring-boot-tests.md"}}}