{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/spring-mvc-multi-tenacy","result":{"data":{"markdownRemark":{"html":"<p>One of our clients aimed to replace old, often DOS based, point of sale systems with a cloud based, SaaS modeled solution. <a href=\"%7B%7B%20site.url%20%7D%7D\">At Bright Inventions</a> we have developed all required components including AWS based back-end processing requests originating from multiple clients. Each business that uses the SaaS point of sale can be considered a tenant in a multi-tenant environment. There many aspects involved when developing multi-tenant application with <a href=\"http://blog.memsql.com/database-multi-tenancy-in-the-cloud-and-beyond/\">data isolation and partitioning being the most discussed topic</a>. However, today I would like to focus on computational and resource isolation aspect. </p>\n<p><img src=\"/images/spring-mvc-multi-tenancy/feeding-animals.jpg\" alt=\"Multiple consumers\"></p>\n<h2>Controlled resource usage</h2>\n<p>In the discussed case each tenant would have multiple iOS based API clients. The exact number varies from 1 to couple of dozens. Each iOS application would be open constantly throughout a sales day and execute frequent requests against the back-end API. In the iOS application there was a code that polls the server for data changes in frequent and regular intervals. Unfortunately a bug slipped through a code review and caused the app to ask the server for changes around 50 times per second instead of once in half of a minute. The bug caused an explosion of API requests issued by a single API client with a throughput 10 to 100 times bigger than expected. To make things worse the rate at which the bug increased polling frequency exceeded back-end the scaling out policy. Soon all request processing threads were busy processing requests issued by only a small percentile of API clients. </p>\n<p>In a multi-tenant application one needs to take special care to prevent tenant \"A\" from affecting, even indirectly, tenant \"B\" operations. We have failed that requirement on the CPU/thread pool level and that caused the support lines to be hot. </p>\n<h2>Reverse proxy request rate limit</h2>\n<p>The first solution that comes to mind is to apply a per API client request rate limiting. In fact this solution is so common that it is available as a configuration opt-in in many servers. For instance <a href=\"https://www.nginx.com/blog/rate-limiting-nginx/\">in NGINX you could do</a>:</p>\n<pre><code>limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;\n\nserver {\n    location /login/ {\n        limit_req zone=mylimit burst=20;\n\n        proxy_pass http://my_upstream;\n    }\n}\n</code></pre>\n<p>The above would only allow up to 10 request per second from the same IP address. Any request that comes in at higher rate would be queued up to specified capacity (<code>burst=20</code>). Any request above the limit would get rejected with 503 status code. </p>\n<p>The nginx approach is battle tested and fairly easy to apply. Instead of using IP address it would be better to group requests by a tenant identifier. However, it may not be easy to determine exactly which tenant is making the request unless the information is easily available in the request headers. For that matter it is good to consider sending the API client identification using a custom HTTP header. For instance if the API client provides <code>X-Tenant-Id: tenant.1</code> you can use it as <code>limit_req_zone $http_x_tenant_id zone=mylimit:10m rate=10r/s;</code>. When using JWT, you often can determine <em>who</em> is making the request by parsing the <code>Authorization</code> header value. </p>\n<h2>Spring MVC request rate limit</h2>\n<p>It is often not feasible to apply the request rate limit at the reverse proxy level. In such scenario we can apply the limit inside Spring MVC application. For start one can try suing <a href=\"http://www.oracle.com/technetwork/java/filters-137243.html\">Servlet Filter</a>. <a href=\"https://stackoverflow.com/questions/10127472/servlet-filter-very-simple-rate-limiting-filter-allowing-bursts\">There are several solutions</a> available including a <a href=\"https://www.eclipse.org/jetty/javadoc/9.4.7.v20170914/org/eclipse/jetty/servlets/DoSFilter.html\">DoSFilter that is part of Jetty project</a>.</p>\n<p>Using a ready-made Servlet Filter is often sufficient especially when the available customization options suit our needs. In case of our client however, we wanted the limits to depend on the <em>size</em> of the client. In other words the more service you buy, the more resources are available to you. Moreover, I wanted to have a have fine-grained control at <strong>a controller action</strong> level. To my surprise such behavior was not easy to accomplish using <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/AsyncHandlerInterceptor.html\">AsyncHandlerInterceptor</a>. Fortunately I did find a way to achieve a desired result using a mix of extensibility points and hacks. </p>\n<p>The first step is to customize <a href=\"https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/RequestMappingHandlerAdapter.html\"><code>RequestMappingHandlerAdapter</code></a> used by Spring MVC to transform <code>@RequestMapping</code> annotation into handler classes. The following configuration class in Kotlin achieves just that:</p>\n<pre><code class=\"language-kotlin\">@Configuration\nclass WebMvcConfiguration : DelegatingWebMvcConfiguration() {\n\n    @Autowired(required = false)\n    private val mvcProperties: WebMvcProperties? = null\n\n    @Inject lateinit var reactiveRequestCommandFactory: ReactiveRequestCommandFactory\n    @Inject lateinit var reactiveRequestsProperties: ReactiveRequestsConfiguration.RequestsProperties\n\n    @Bean\n    override fun requestMappingHandlerAdapter(): RequestMappingHandlerAdapter {\n        //copy pasted from WebMvcConfigurationSupport\n        val argumentResolvers = ArrayList&#x3C;HandlerMethodArgumentResolver>()\n        addArgumentResolvers(argumentResolvers)\n\n        val returnValueHandlers = ArrayList&#x3C;HandlerMethodReturnValueHandler>()\n        addReturnValueHandlers(returnValueHandlers)\n\n        val adapter = RateLimitingRequestMappingHandlerAdapter(reactiveRequestCommandFactory, reactiveRequestsProperties)\n\n        adapter.setContentNegotiationManager(mvcContentNegotiationManager())\n        adapter.messageConverters = messageConverters\n        adapter.webBindingInitializer = configurableWebBindingInitializer\n        adapter.customArgumentResolvers = argumentResolvers\n\n        adapter.customReturnValueHandlers = returnValueHandlers\n\n        val requestBodyAdvices = ArrayList&#x3C;RequestBodyAdvice>()\n        requestBodyAdvices.add(JsonViewRequestBodyAdvice())\n        adapter.setRequestBodyAdvice(requestBodyAdvices)\n\n        val responseBodyAdvices = ArrayList&#x3C;ResponseBodyAdvice&#x3C;*>>()\n        responseBodyAdvices.add(JsonViewResponseBodyAdvice())\n        adapter.setResponseBodyAdvice(responseBodyAdvices)\n\n        configureAsync(adapter)\n\n\n        adapter.setIgnoreDefaultModelOnRedirect(mvcProperties?.isIgnoreDefaultModelOnRedirect != false)\n        return adapter\n    }\n\n    private fun configureAsync(adapter: RequestMappingHandlerAdapter) {\n        //expose field publicly\n        val configurer = object : AsyncSupportConfigurer() {\n            public override fun getTaskExecutor() = super.getTaskExecutor()\n            public override fun getTimeout() = super.getTimeout()\n            public override fun getCallableInterceptors() = super.getCallableInterceptors()\n            public override fun getDeferredResultInterceptors() = super.getDeferredResultInterceptors()\n        }\n\n        configureAsyncSupport(configurer)\n\n        if (configurer.taskExecutor != null) {\n            adapter.setTaskExecutor(configurer.taskExecutor)\n        }\n\n        if (configurer.timeout != null) {\n            adapter.setAsyncRequestTimeout(configurer.timeout!!)\n        }\n\n        adapter.setCallableInterceptors(configurer.callableInterceptors)\n        adapter.setDeferredResultInterceptors(configurer.deferredResultInterceptors)\n    }\n}\n</code></pre>\n<p>Note that we are injecting <code>reactiveRequestCommandFactory</code> and <code>reactiveRequestsProperties</code> and pass them into our core <code>RateLimitingRequestMappingHandlerAdapter</code>. All other code is a mostly a copy-paste from <code>DelegatingWebMvcConfiguration</code> base class.</p>\n<pre><code class=\"language-kotlin\">@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\nannotation class RequestCommand(\n    val enabled: Boolean = true,\n    val timeoutInMillis: Int = 60_000\n)\n\nclass RateLimitingRequestMappingHandlerAdapter(private val reactiveRequestCommandFactory: ReactiveRequestCommandFactory,\n                                               private val reactiveRequestProperties: ReactiveRequestsConfiguration.RequestsProperties) : RequestMappingHandlerAdapter() {\n    private val handlerMethodConfigurationsCache = ConcurrentHashMap&#x3C;HandlerMethod, RequestCommandConfiguration>()\n\n    override fun createInvocableHandlerMethod(handlerMethod: HandlerMethod): ServletInvocableHandlerMethod? {\n        val configuration = requestCommandConfigurationFor(handlerMethod)\n\n        return when {\n            configuration.enabled &#x26;&#x26; reactiveRequestProperties.enabled -> CommandInvocableHandlerMethod(handlerMethod, reactiveRequestCommandFactory, configuration)\n            else -> super.createInvocableHandlerMethod(handlerMethod)\n        }\n    }\n\n    private fun requestCommandConfigurationFor(handlerMethod: HandlerMethod): RequestCommandConfiguration {\n        return handlerMethodConfigurationsCache.getOrPut(handlerMethod) {\n            val method = handlerMethod.getMethodAnnotation(RequestCommand::class.java)\n            val methodOrController = method ?: AnnotatedElementUtils.findMergedAnnotation(handlerMethod.beanType, RequestCommand::class.java)\n            methodOrController?.let { RequestCommandConfiguration(it) } ?: RequestCommandConfiguration.Default\n        }\n    }\n}\n</code></pre>\n<p>Inside of <code>createInvocableHandlerMethod</code> we get the configuration for the <code>handlerMethod</code> determined by Spring MVC. The <code>handlerMethod</code> denotes a controller action. Then we decide if we should use the rate limiting handler or fallback to the default one. In case we need to apply rate limiting we switch the invocation to use custom <code>CommandInvocableHandlerMethod</code>:</p>\n<pre><code class=\"language-kotlin\">class CommandInvocableHandlerMethod(private val handlerMethod: HandlerMethod,\n                                    private val requestCommandFactory: RequestCommandFactory,\n                                    private val configuration: RequestCommandConfiguration) : ServletInvocableHandlerMethod(handlerMethod) {\n    private lateinit var returnValueHandlers: HandlerMethodReturnValueHandlerComposite\n\n    override fun invokeForRequest(request: NativeWebRequest?, mavContainer: ModelAndViewContainer?, vararg providedArgs: Any?): Any {\n        // same as super.invokeForRequest(request, mavContainer, *providedArgs)\n        // but with request passed to do invoke\n        val args = this.getMethodArgumentValuesCallable.invoke(request, mavContainer, providedArgs)\n        val result = doInvokeWithRequest(request, args)\n        return result\n    }\n\n    private fun doInvokeWithRequest(request: NativeWebRequest?, args: Array&#x3C;out Any?>?): Any {\n        val nativeRequest = request?.getNativeRequest(HttpServletRequest::class.java)\n\n        // If the response has already set error status code tomcat will not wait for async result\n        return if (nativeRequest != null &#x26;&#x26; nativeRequest.dispatcherType == DispatcherType.REQUEST) {\n            val callSuper = Callable {\n                super.doInvoke(*(args ?: emptyArray()))\n            }\n\n            val job = callSuper\n\n            val context = RequestCommandContext(configuration, handlerMethod, SecurityContextHolder.getContext(), job)\n\n            val result = requestCommandFactory.createSingle(context)\n\n            MonoDeferredResult(result)\n        } else {\n            super.doInvoke(*(args ?: emptyArray()))\n        }\n    }\n\n    override fun setHandlerMethodReturnValueHandlers(returnValueHandlers: HandlerMethodReturnValueHandlerComposite?) {\n        this.returnValueHandlers = returnValueHandlers!!\n        super.setHandlerMethodReturnValueHandlers(returnValueHandlers)\n    }\n\n    override fun wrapConcurrentResult(result: Any?): ServletInvocableHandlerMethod {\n        return ConcurrentResultHandlerMethod(result, ConcurrentResultMethodParameter(result))\n    }\n\n...\n</code></pre>\n<p>The above code is using <em>private</em> <a href=\"https://github.com/spring-projects/spring-framework/blob/cc74a28/spring-web/src/main/java/org/springframework/web/method/support/InvocableHandlerMethod.java#L147\"><code>getMethodArgumentValues</code></a> API to achieve the desired behavior‼ The <code>doInvokeWithRequest</code> checks if an asynchronous dispatch should be performed and if so creates a <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html\"><code>Mono</code></a> that denotes the result of the controller action method invocation. <code>RequestCommandContext</code> stores the information about target controller action method and current security context. The security context needs to be preserved when invoking the controller action on a different thread. The <a href=\"https://gist.github.com/miensol/cca73d158ce8e7664ed653a30fc8dc70\"><code>ConcurrentResultHandlerMethod</code></a> extends <code>ServletInvocableHandlerMethod</code> to add support for using <code>Mono</code> on regular, synchronous controller action. The core logic of rate limiting is delegated to <code>ReactiveRequestCommandFactory</code>:</p>\n<pre><code class=\"language-kotlin\">interface ReactiveRequestCommandFactory {\n    fun createSingle(context: RequestCommandContext): Mono&#x3C;Optional&#x3C;Any>>\n}\n</code></pre>\n<p>The factory responsibilty it to convert a request context into an async result. Spring MVC 5 <a href=\"https://docs.spring.io/spring-framework/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html\">has built in support for Reactor</a> hence we decided to use this implementation of <a href=\"http://www.reactive-streams.org/\">Reactive Streams specification</a>. The <code>ReactiveRequestCommandFactory</code> looks as follows:</p>\n<pre><code class=\"language-kotlin\">@Component\nclass ReactorRequestCommandFactory(\n    threadPoolPropertiesCalculator: ThreadPoolPropertiesCalculator,\n    @param:Named(\"reactiveRequestsScheduler\")\n    private val reactiveRequestsScheduler: Schedule\n) : ReactiveRequestCommandFactory {\n    private val threadPoolPropertiesCalculator = HystrixConfigurationAwarePropertiesCalculator(threadPoolPropertiesCalculator)\n    private val tenants = ConcurrentHashMap&#x3C;String, TenantTaskCoordinator>()\n\n    override fun createSingle(context: RequestCommandContext): Mono&#x3C;Optional&#x3C;Any>> {\n        val properties = threadPoolPropertiesCalculator.newThreadPoolProperties(context)\n\n        val taskCoordinator = tenants.computeIfAbsent(properties.threadPoolName) {\n            TenantTaskCoordinator(reactiveRequestsScheduler,\n                maximumConcurrency = properties.maximumThreads,\n                maximumQueueSize = properties.maximumQueueSize,\n                name = properties.threadPoolName\n            )\n        }\n\n        val optionalCallable = OptionalCallable(context.job)\n        val configureRequestAttributes = SpringServletRequestAttributesCallable(optionalCallable)\n        val configureLocale = SpringLocaleContextCallable(configureRequestAttributes)\n        val securityCallable = DelegatingSecurityContextCallable(configureLocale, context.securityContext)\n\n        return taskCoordinator.execute(securityCallable)\n            .timeout(Duration.ofMillis(context.configuration.timeoutInMillis.toLong()))\n    }\n}\n\nclass OptionalCallable(private val inner: RequestHandlerJob) : Callable&#x3C;Optional&#x3C;Any>> {\n    override fun call(): Optional&#x3C;Any> = Optional.ofNullable(inner.call())\n}\n</code></pre>\n<p>The <code>ThreadPoolPropertiesCalculator</code> calculates how concurrent threads and how big the requests queue should be for particular tenant or tenants group. Then for each tenant group, in particular a single tenant, we create a <code>TenantTaskCoordinator</code> responsible for calculating and enforcing limits on concurrently handled requests. Further down we decorate the <code>Callable</code> representing the actual request handling with security delegation, locale configuration and request attributes setup. Finally, we ask the <code>TenantTaskCoordinator</code> to execute the decorated job with a configured timeout.</p>\n<p>The last piece of the puzzle, namely <code>TenantTaskCoordinator</code> requires <a href=\"%7B%25%20post_url%202018-01-04-multi-tenancy-task-scheduler%20%25%7D\">a separate blog post</a> so stay tuned.</p>","excerpt":"One of our clients aimed to replace old, often DOS based, point of sale systems with a cloud based, SaaS modeled solution. At Bright…","frontmatter":{"slug":null,"title":"Multi tenancy in Spring MVC","description":null,"author":"piotr","tags":["spring","mvc","spring-boot","multi-tenant","reactive","reactor"],"date":"2017-12-11T23:00:00.000Z","image":"/images/spring-mvc-multi-tenancy/feeding-animals.jpg"},"timeToRead":9,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-12-spring-mvc-multi-tenacy.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-12-spring-mvc-multi-tenacy.md"}}}