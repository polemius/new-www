{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/injectable-android-viewmodels","result":{"data":{"markdownRemark":{"html":"<p>In the following post I'm going to show a simple (almost boilerplate-free) yet powerful implementation of the view models dependency injection on Android using Dagger.</p>\n<p>If you haven't read about the latest <a href=\"https://developer.android.com/topic/libraries/architecture/.html\">Android Architecture Components libraries</a>, the MVVM pattern and the <a href=\"https://developer.android.com/topic/libraries/architecture/viewmodel.html\">ViewModel</a> class yet, please read it first as I don't explain it here.</p>\n<h1>The Android weaknesses</h1>\n<p>I think the fact that Google has decided to help developers by creating their own library for supporting the MVVM pattern on the Android platform was a really good move.</p>\n<p>A few months before its release I was wondering what was the best approach to introduce the MVP or MVVM pattern on Android. I have tested or reviewed a few libs on GitHub and none of them seemed good enough for me - either due to their limitations or a huge amount of boilerplate code they required. Also the way they were implemented and the number of reported bugs were not encouraging.</p>\n<p>I was envious of the simple approach the iOS developers have - they can instantiate a view controller on their own and pass a view model directly to it (e.g. via the constructor). The iOS system also doesn't kill the view controller when the screen orientation changes so it doesn't have to obtain the view model again and, at the same time, the view model gets destroyed with the view controller when it's not needed anymore (provided that you don't hold another reference to it).</p>\n<p>But on Android you start with an activity component and you can't prepare the view model outside of its lifecycle easily. Also storing the reference to the view model only in the activity which gets destroyed on every configuration change (like screen orientation) will destroy the view model as well and it's not convenient. If you would like the view model to survive, you would have to hold a reference to it somewhere else but then another problems arise e.g. how to clean the view model when it's not needed anymore or how to make every activity of the same class to use a different view model instance.</p>\n<p>The Google's <code>ViewModel</code> was designed to help with such issues. Unfortunately, it still needs to be created during the activity lifecycle but with several Dagger tweaks you can easily inject any view model's dependencies to it.</p>\n<p><img src=\"/images/injectable-android-viewmodels/syringe-1884758_1920.jpg\" alt=\"Injection\">{: .center-image}</p>\n<h1>Injectable ViewModels</h1>\n<p>Before we begin to play with the code I wanted to add that I have googled other people's approaches to view model injections and I didn't like them too much because of the significant amount of the boilerplate code (e.g. writing a separate view model factory per view model). The <del>best one</del> <em>(not any more - read the note below)</em>, which my example is based on, comes from the <a href=\"https://github.com/googlesamples/android-architecture-components/tree/master/GithubBrowserSample\">Google's samples repository</a>. I have simplified some parts of it and rewritten it in Kotlin.</p>\n<p><em>Note: you can access the whole code used in this example <a href=\"https://github.com/azabost/simple-mvvm-example/tree/7b051fd7a16853e3d9655767a887d9a830133d2d\">on GitHub</a>.</em></p>\n<p><em>Another note: if you would like to read about a newer solution for injecting ViewModels which I find better, <a href=\"https://brightinventions.pl/blog/android-viewmodel-injections-revisited/\">click here</a>.</em></p>\n<h2>Simple factory</h2>\n<p>The default library's factory instantiates view models using empty constructors. Of course, we can't use it as we are going to create the view models with non-empty constructors, passing the dependencies obtained from Dagger.</p>\n<p>The <code>ViewModelProvider.Factory</code> interface defines only one method:</p>\n<pre><code class=\"language-java\">@NonNull\n&#x3C;T extends ViewModel> T create(@NonNull Class&#x3C;T> modelClass);\n</code></pre>\n<p>As you can see, it takes the class of a view model and it must return its instance.</p>\n<p>In order to use a single simple and universal factory (which is the main point of this post) for all the view models we need to create a map of <code>Provider</code>s for every view model class. While I was analysing the mentioned Google's sample I didn't know how the map generation works and it wasn't very easy to understand so I'm going to exaplain it a little more here to save you the trouble.</p>\n<h3>Generating the map</h3>\n<p>If you have already used Dagger, you might have also noticed the code it generates. Most of that code are the <code>Component</code>s, <code>Provider</code>s, <code>Factory</code>s etc. The <code>Provider</code> is an object which <em>provides</em> the instances of some class (<code>Factory</code> is also a <code>Provider</code>).</p>\n<p>The <code>MapKey</code> annotation (<a href=\"https://google.github.io/dagger/api/2.13/dagger/MapKey.html\">docs</a>) lets you generate a map of objects provided by Dagger or the <code>Provider</code>s of those objects. In our example we will need the following map:</p>\n<p><code>Map&#x3C;Class&#x3C;? extends ViewModel>, Provider&#x3C;ViewModel>></code></p>\n<p>which can be translated to Kotlin as:</p>\n<p><code>Map&#x3C;Class&#x3C;out ViewModel>, @JvmSuppressWildcards Provider&#x3C;ViewModel>></code></p>\n<p><em>Note: Dagger generates Java sources and that's why we must remember about the variance differences between Java and Kotlin (<a href=\"https://kotlinlang.org/docs/reference/generics.html\">generics docs</a>, <a href=\"https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html\">Java to Kotlin interoperability docs</a>) which could be troublesome if you don't use the <code>@JvmSuppressWildcards</code> annotation, resulting in this error:</em></p>\n<blockquote>\n<p>error: [dagger.android.AndroidInjector.inject(T)] java.util.Map&#x3C;java.lang.Class&#x3C;? extends android.arch.lifecycle.ViewModel>,? extends javax.inject.Provider&#x3C;android.arch.lifecycle.ViewModel>> cannot be provided without an @Provides-annotated method.</p>\n</blockquote>\n<p>This map's entries consist of a key - a class of any view model and a value - a <code>Provider</code> of any view model. Obviously, we must feed the map with the corresponding <code>Provider</code>s for every view model, e.g. <code>ViewModelA -> Provider&#x3C;ViewModelA></code>. With such a map the factory will be able to easily return an instance of any view model with all its dependencies fulfilled by Dagger.</p>\n<p>In order to generate the map we need two elements: a map key definition and a module with view model <em>bindings</em>.</p>\n<p>The map key definition is an annotation type which has a single member whose type is the map key type. It may look like this:</p>\n<pre><code class=\"language-kotlin\">import android.arch.lifecycle.ViewModel\nimport dagger.MapKey\nimport kotlin.reflect.KClass\n\n@MustBeDocumented\n@Target(AnnotationTarget.FUNCTION)\n@Retention(AnnotationRetention.RUNTIME)\n@MapKey\nannotation class ViewModelKey(val value: KClass&#x3C;out ViewModel>)\n</code></pre>\n<p>And then we can use it in a module like below.</p>\n<pre><code class=\"language-kotlin\">import android.arch.lifecycle.ViewModel\nimport com.azabost.simplemvvm.ui.main.MainViewModel\nimport dagger.Binds\nimport dagger.Module\nimport dagger.multibindings.IntoMap\n\n@Module\nabstract class ViewModelModule {\n\n    @Binds\n    @IntoMap\n    @ViewModelKey(MainViewModel::class)\n    abstract fun bindMainViewModel(mainViewModel: MainViewModel): ViewModel\n}\n</code></pre>\n<p><code>@Binds</code> methods are a drop-in replacement for <code>@Provides</code> methods that simply return an injected parameter. Combining it with <code>@IntoMap</code> and our key (<code>@ViewModelKey</code>) will put a provider of the returned object into the map under the key specified by the key annotation's parameter. In this case the <code>Provider&#x3C;MainViewModel></code> instance will be put under the <code>MainViewModel::class</code> key. Kotlin will also translate the <code>KClass</code> into <code>Class</code> for Java compatibility.</p>\n<p><em>Note: you may want to read the <code>Binds</code> <a href=\"https://google.github.io/dagger/api/2.13/dagger/Binds.html\">docs</a>, <code>IntoMap</code> <a href=\"https://google.github.io/dagger/api/2.13/dagger/multibindings/IntoMap.html\">docs</a> and multibindings <a href=\"https://google.github.io/dagger/multibindings.html\">docs</a>.</em></p>\n<h3>Using the map in the factory</h3>\n<p>The view model factory which uses the generated map will be as simple as this:</p>\n<pre><code class=\"language-kotlin\">import android.arch.lifecycle.ViewModel\nimport android.arch.lifecycle.ViewModelProvider\nimport javax.inject.Inject\nimport javax.inject.Provider\nimport javax.inject.Singleton\n\n@Singleton\nclass InjectingViewModelFactory @Inject constructor(\n        private val viewModelProviders: Map&#x3C;Class&#x3C;out ViewModel>, @JvmSuppressWildcards Provider&#x3C;ViewModel>>\n) : ViewModelProvider.Factory {\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun &#x3C;T : ViewModel> create(modelClass: Class&#x3C;T>): T {\n        val provider = viewModelProviders[modelClass]\n                ?: viewModelProviders.entries.first { modelClass.isAssignableFrom(it.key) }.value\n\n        return provider.get() as T\n    }\n}\n</code></pre>\n<p>And we can also add it to the same Dagger module:</p>\n<pre><code class=\"language-kotlin\">import android.arch.lifecycle.ViewModel\nimport android.arch.lifecycle.ViewModelProvider\nimport com.azabost.simplemvvm.ui.main.MainViewModel\nimport dagger.Binds\nimport dagger.Module\nimport dagger.multibindings.IntoMap\n\n@Module\nabstract class ViewModelModule {\n\n    @Binds\n    @IntoMap\n    @ViewModelKey(MainViewModel::class)\n    abstract fun bindMapViewModel(mapViewModel: MainViewModel): ViewModel\n\n    @Binds\n    abstract fun bindViewModelFactory(factory: InjectingViewModelFactory): ViewModelProvider.Factory\n}\n</code></pre>\n<h2>Obtaining view models</h2>\n<p>In the activity you can now inject the factory:</p>\n<pre><code class=\"language-kotlin\">@Inject\nlateinit var vmFactory: ViewModelProvider.Factory\n</code></pre>\n<p>and use it to obtain the view model:</p>\n<pre><code class=\"language-kotlin\">val vm = ViewModelProviders.of(this, vmFactory).get(MainViewModel::class.java)\n</code></pre>\n<p>Don't forget to annotate your view model's constructor with <code>@Inject</code>:</p>\n<pre><code class=\"language-kotlin\">class MainViewModel @Inject constructor(\n        private val gitHubClient: GitHubClient\n) : ViewModel(), MainVM, LoadingVM, DataVM {\n    ...\n}\n</code></pre>\n<p>If it seems too complicated to you, please take a look at the diagram below. It may help you to see the big picture.</p>\n<p><img src=\"/images/injectable-android-viewmodels/diagram.png\" alt=\"Diagram\">{: .center-image}</p>","excerpt":"In the following post I'm going to show a simple (almost boilerplate-free) yet powerful implementation of the view models dependency…","frontmatter":{"slug":null,"title":"Injectable Android ViewModels","description":null,"author":"azabost","tags":["android","kotlin","dagger","viewmodel","mvvm"],"date":"2017-12-10T23:00:00.000Z","image":"/images/injectable-android-viewmodels/syringe-1884758_1920.jpg"},"timeToRead":7,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-11-injectable-android-viewmodels.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2017-12-11-injectable-android-viewmodels.md"}}}