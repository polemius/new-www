{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/mvvm-flowcontrollers","result":{"data":{"markdownRemark":{"html":"<p><img src=\"/images/mvvm-flowcontrollers/mvvm-flowcontrollers.jpeg\" alt=\"Header\">{: .center-image}</p>\n<p>There are many different approaches to building an iOS application. MVC (Model View Controller), MVP (Model View Presenter), MVVM (Model View ViewModel), VIPER (View Interactor Presenter Entity Routing), Redux... And surely, you can name many others. I've been writing iOS apps for some time now, and I have noticed that MVVM + FlowControllers approach works pretty well for me.\nIn this post I'd like to focus on \"Why?\" I use it over other approaches and \"How?\" I use it in my apps.</p>\n<h1>Why?</h1>\n<h2>The beginning</h2>\n<p>Starting iOS development is usually connected with learning basic patterns that you can use to solve problems that you will run into while struggling to create your first screens in the app. Most probably the first pattern that will take care of your views and logic behind them will be MVC, which is very popular among iOS developers (but not only them). This is mostly caused by the fact that Apple highly promotes this pattern across the <code>UIKit</code> framework and code examples that you can find in their tutorials.</p>\n<h2>Is MVC bad?</h2>\n<p>Yes! It's the worst of all! It causes Massive ViewControllers to appear over your app... Jokes aside...  </p>\n<p>No, it's not. I was really glad when I've recently read post <a href=\"http://aplus.rs/2017/much-ado-about-ios-app-architecture/\">\"Much ado about iOS app architecture\" </a>. I cannot say that I fully agree with everything that is said there, but there are parts that I can surely identify with. Why was I glad to read this? Because of this sentence:  </p>\n<p>\"No one is forcing you to implement multiple DataSources in one Controller. To initiate network calls in viewDidLoad. To parse JSONs in UIViewController. To hard-wire Views with Singleton instances.\"  </p>\n<p>Many developers blame MVC for its horrible mess and chaos which in fact is created by developers themselves. If you lack discipline, then even VIPER will not help you. Certain patterns may make it easier to structure the code properly and keep it clean, but it's always up to you whether you keep the discipline or not.</p>\n<p>Should I use MVC if it is not that bad in the end? If I was a skilled consultant I should probably say \"it depends\". MVC obviously has its own pros and cons and I bet you can find many great articles that will help you to make up your mind.</p>\n<h2>Why MVVM?</h2>\n<p>If MVC is not that bad, then what are my motives for following the MVVM path? Just to name a few of them:  </p>\n<ul>\n<li>It allows me to move a big portion of my code far away from <code>UIKit</code> (<a href=\"https://brightinventions.pl/blog/are-your-views-dumb-enough/\">Which gives an ability to test this code faster - as macOS frameworks </a>).  </li>\n<li>It allows me to test the logic that drives my views easier.  </li>\n<li>It works really well with reactive programming approaches (but you don't need to use them to benefit from MVVM)  </li>\n</ul>\n<p>So now, after adopting the principles of MVVM pattern, I'm able to have my passive views (as dumb as possible) and my logic that drives my views which is also separated from the UIKit.  </p>\n<p>Why not going any further with the division approach that patterns like VIPER target really well? Well... you can do that. I've never used VIPER in a big project before (I'd be glad to hear your opinion on this!), however, I'd say that this kind of patterns could be an easy overkill for a small/medium sized apps.<br>\nI feel that MVVM works really well if you want to keep your solutions easy to understand while having an ability to easily test your code and have a nice separation from UIKit-dependant parts of your code.</p>\n<h2>FlowControllers</h2>\n<p>What are the motives for using them?<br>\nIt is not something unusual when inside ViewController \"A\" you find code that is responsible for transition to screen \"B\". A problem with this approach is that out of a sudden you create a tight coupling between these two entities and you might find yourself in trouble if you want to split or reuse them in other contexts.<br>\nWell... It's always good to ask a question - Is it a problem? If you're working on something simple then using this kind of navigation may be completely fine, however, if you're up to something more complicated - adding a flowController will surely help. Keep in mind that adding a flowController is not a high cost task - I tend to use them even in simple apps as they help me to organize my code better and give me a good look on how navigation in my app works. Adding a flowController to your app will help you with:  </p>\n<ul>\n<li>Keeping your screens separated from each other, which will allow you to modularise and reuse them easily.  </li>\n<li>Controlling flow in parts of your app (You will probably have many different flowControllers)  </li>\n<li>Dependency injection place for your <code>ViewModels</code></li>\n</ul>\n<h2>The discipline</h2>\n<p>A pure fact that you start using MVVM and <code>FlowControllers</code> will not instantly make your code base clean. Guess what? You can still end up with <code>Massive ViewModels</code>! It's up to you whether you keep yourself tight and organize your code well.</p>\n<h1>How?</h1>\n<h2>MVVM</h2>\n<p>Ok, so how do I use MVVM? How do I keep my <code>ViewModels</code> clean? How do I use <code>FlowControllers</code>? Jump on board and let's see a quick example that will allow us to see the concept in use.<br>\nI have to admit that while I was taking my first step into iOS development, I considered <code>ViewModel</code> to be an object that holds values which would be displayed by a view. At that point I did not see that much value in using <code>ViewModels</code>. What changed my point of view was the approach that you can read about on <a href=\"https://msdn.microsoft.com/en-us/library/hh848246.aspx\">Microsoft patterns and practices</a>. The core information for me was the fact that the <code>View</code> layer in Microsoft's approach was represented as XAML (quote: \"with a limited code-behind that does not contain business logic\"). Ok... So does it mean that <code>ViewModel</code> is not only about holding values represented by our views? Can it also contain logic that drives these views? YES! Following this approach on iOS, it encourages you to keep your view layer simple (which in case of MVVM would be both <code>UIView</code> and <code>UIViewController</code>) and move the logic to <code>ViewModel</code>. This is the first step that allows us to reach better testability and move our code far away from <code>UIKit</code>.</p>\n<p>Let's go step by step through a quick example of a MVVM pattern used together with <code>FlowController</code>. </p>\n<p>Let's start with <code>AppDelegate</code>. What do we have here?</p>\n<pre><code class=\"language-swift\">   class AppDelegate: UIResponder, UIApplicationDelegate {\n\n    var window: UIWindow?\n    var mainNavigationController: UINavigationController!\n    var mainFlowController: MainFlowController!\n    \n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool {\n        \n        mainNavigationController = UINavigationController()\n        \n        window = UIWindow(frame: UIScreen.main.bounds)\n        window?.rootViewController = mainNavigationController\n        window?.makeKeyAndVisible()\n        \n        mainFlowController = MainFlowController(rootNavigationController: mainNavigationController)\n        mainFlowController.startFlow()\n        \n        return true\n    }\n\n}\n</code></pre>\n<p>The first thing that is important is that I create my <code>MainFlowController</code> which will be responsible for controlling my application flow. The only dependency that I pass here is my main navigation controller that is the root controller of my main window. I've also seen different approaches that pass <code>UIWindow</code> to a flowController directly, however, if you do not need it, then I would prefer to have this \"lighter\" object which has a more defined responsibility.</p>\n<p>What about the <code>MainFlowController</code> itself? </p>\n<pre><code class=\"language-swift\">class MainFlowController {\n    \n    private let rootNavigationController: UINavigationController\n    \n    private lazy var entryViewModel: EntryViewModel = {\n        let fetcher = FakeUserFetcher()\n        let viewModel = EntryDefaultViewModel(userFetcher: fetcher)\n        viewModel.onUserNameSelected = self.onUserNameSelected\n        return viewModel\n    }()\n    private lazy var entryViewController = EntryViewController(viewModel: entryViewModel)\n    \n    init(rootNavigationController: UINavigationController) {\n        self.rootNavigationController = rootNavigationController\n    }\n    \n    func startFlow() {\n        rootNavigationController.pushViewController(entryViewController, animated: true)\n    }\n    \n    func onUserNameSelected(userName: String) {\n        print(\"name: \\(userName)\");\n        // Show next screen using selected user name\n    }\n    \n}\n</code></pre>\n<p>The core element of this <code>FlowController</code> is surely the <code>startFlow</code> method, which in this case pushes a new <code>ViewController</code> to our navigation stack. This <code>ViewController</code> is created with a <code>ViewModel</code> as a parameter. The <code>viewModel</code> will be very important for us in a while, however, from the <code>FlowController's</code> point of view, we're especially interested in <code>onUserNameSelected</code> closure. This is the output of the <code>ViewModel</code> that our <code>FlowController</code> could be potentially interested in. For example, after selecting a user name we could open the next screen that allows us to select a birthday, surname, favourite pet or simply displays the name in a fancy way. Your <code>FlowController</code> allows you to control the flow of your application and makes the <code>ViewModel</code> unaware of the context that it's used in. <code>ViewModel</code> has its job to do and after it's done our <code>FlowController</code> will be notified about it. </p>\n<p>The ViewController</p>\n<pre><code class=\"language-swift\">class EntryViewController: UIViewController {\n\n    private let viewModel: EntryViewModel\n    \n    private lazy var fetchUserButton: UIButton = {        \n        let button = UIButton()\n        button.addTarget(self, action: #selector(onFetchUserButtonTapped), for: .touchUpInside)\n        // ...setup button\n        return button\n    }()\n    \n    private lazy var selectUserButton: UIButton = {\n        let button = UIButton()\n        button.addTarget(self, action: #selector(onSelectUserButtonTapped), for: .touchUpInside)\n        // ...setup button\n        return button\n    }()\n\n    private let currentUserLabel = UILabel()\n    \n    init(viewModel: EntryViewModel) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil) // Layout created programamtically, sorry for that ;(\n    }\n    \n    required init?(coder aDecoder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n    \n    override func loadView() {\n        super.loadView()\n        setupView()\n        setupObservers()\n    }\n    \n    private func setupObservers() {\n        currentUserLabel.reactive.text &#x3C;~ self.viewModel.userName // bind viewModels output to your UI\n    }\n    \n    @objc func onFetchUserButtonTapped() {\n        viewModel.fetchUser()\n    }\n    \n    @objc func onSelectUserButtonTapped() {\n        viewModel.selectUser()\n    }\n\n    private func setupView() {\n        // setup constraints etc\n    }\n    \n}\n</code></pre>\n<p>In my case, <code>ViewController</code> is a part of <code>View</code> layer in MVVM. What happens here is: </p>\n<ul>\n<li>Binding <code>ViewModel's</code> output to UI components</li>\n<li>Invoke methods from <code>ViewModel</code></li>\n<li>If needed, passing lifecycle methods to <code>ViewModel</code></li>\n<li>Layout setup</li>\n</ul>\n<p>And last but not least - The ViewModel</p>\n<pre><code class=\"language-swift\">protocol EntryViewModel {\n    func fetchUser()    \n    func selectUser()\n    \n    var onUserNameSelected: ((String)->Void)? {get set} // If you're using Reactive frameworks, you can also implement this as a stream\n    // var onNextSelected: (()->Void)? // Other callbacks could exist here, they do not need to pass data\n\n    var userName: Property&#x3C;String?> {get} // ReadOnly property that allows others to observe its changes, but not change the property from outside of viewModel\n}\n\nclass EntryDefaultViewModel: EntryViewModel {\n    \n    private let userFetcher: UserFetcher\n    private var mutableUserName: MutableProperty&#x3C;String?> = MutableProperty(nil)\n    lazy var userName: Property&#x3C;String?> = Property(self.mutableUserName)\n    weak var onUserNameSelected: ((String)->Void)?\n    \n    // injecting dependencies to your viewModel \n    init(userFetcher: UserFetcher) {\n        self.userFetcher = userFetcher\n    }\n    \n    func selectUser() {\n        if let userName = userName.value {\n            onUserNameSelected?(userName)\n        }\n    }\n    \n    func fetchUser() {        \n        // Bind the result of fetchUser() function to a mutableUserName property\n        mutableUserName &#x3C;~ userFetcher.fetchUser().map { $0.name }\n    }\n    \n}\n</code></pre>\n<p>The <code>ViewModel's</code> part is the actual beating heart for our <code>View</code> layer. It will allow the <code>View</code> to observe changes in properties it exposes. It will also contain logic for various behaviours. Keep in mind that you do not need to keep the entire logic inside the <code>ViewModel</code>, you can easily extract it and add it as dependency - this is what happens with <code>userFetcher</code>. This allows us to keep our <code>ViewModels</code> cleaner and easily testable as we can mock our dependencies.</p>\n<h1>Summary</h1>\n<p>Following the way of MVVM + FlowControllers has helped me a lot in separating/organising my code and making in more testable. If I had to pinpoint three benefits of using this approach that are most valuable for me, then it would be:  </p>\n<ul>\n<li><code>ViewControllers</code> that can be easily reused in different scenarios  </li>\n<li>Comfortable testing of <code>ViewModels</code> that contain your logic and are not coupled with <code>UIKit</code>  </li>\n<li>Application modules that have their navigation defined in one place</li>\n</ul>\n<p>If you have never used a similar approach to your apps, then I'd fully encourage you to try it!</p>\n<p>Would you like to learn more about this topic? Check these out:<br>\n<a href=\"http://merowing.info/2016/01/improve-your-ios-architecture-with-flowcontrollers/\">Improve your iOS Architecture with FlowControllers</a><br>\n<a href=\"https://www.swiftbysundell.com/podcast/10\">Swift By Sundell - \"Boy, I have a lot of thoughts on this\", with special guest Soroush Khanlou</a><br>\n<a href=\"https://www.youtube.com/watch?v=a1g3k3NObkE\">Coordinators – Soroush Khanlou</a></p>\n<p><em>This article is cross-posted with <a href=\"https://eliaszsawicki.com/\">my personal blog</a>.</em></p>","excerpt":"Header{: .center-image} There are many different approaches to building an iOS application. MVC (Model View Controller), MVP (Model View…","frontmatter":{"slug":null,"title":"My motives for MVVM + FlowControllers path","description":null,"author":"eliasz","tags":["iOS","Swift"],"date":"2018-01-11T23:00:00.000Z","image":null},"timeToRead":10,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-12-mvvm-flowcontrollers.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-12-mvvm-flowcontrollers.md"}}}