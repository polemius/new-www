{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/forward-compatible-enums-in-kotlin","result":{"data":{"markdownRemark":{"html":"<p>A few years ago Adam outlined\n<a href=\"https://brightinventions.pl/blog/8-steps-to-keep-your-api-sane\">8 steps to keep your API sane</a>\nin his blog post which I really recommend if you haven't seen it yet.\nThe second step there, \"be liberal in what the app accepts\", is quite a\nspecific one because it is applicable not only to the backend side of\nthe API but also, if not the most, the clients of that API.</p>\n<p>I cannot stress enough the importance of that rule in the \"offline\nfirst\" apps. Let's take a look at some example.</p>\n<h1>Example: 9GAG post tags</h1>\n<p>This is a screenshot where you can see a part of the tags list from the\n9GAG Android app.</p>\n<p><img src=\"/images/forward-compatible-enums-in-kotlin/9gag-categories.jpg\" alt=\"9GAG post tags list\"></p>\n<p>At least some of these tags look like they could have the appropriate\ntranslations, e.g. the \"Music\" tag. I'm not saying 9GAG actually\ntranslates them, but it would be understandable if they did. In case of\nAndroid, we could use the\n<a href=\"https://developer.android.com/guide/topics/resources/localization\">string resource XML files for translations</a>\nlike this:</p>\n<p><em>src/main/res/values/strings.xml</em></p>\n<pre><code class=\"language-xml\">&#x3C;resources>\n    &#x3C;string name=\"tag_music\">Music&#x3C;/string>\n    &#x3C;string name=\"tag_art\">Art&#x3C;/string>\n&#x3C;/resources>\n</code></pre>\n<p><em>src/main/res/values-pl/strings.xml</em></p>\n<pre><code class=\"language-xml\">&#x3C;resources>\n    &#x3C;string name=\"tag_music\">Muzyka&#x3C;/string>\n    &#x3C;string name=\"tag_art\">Sztuka&#x3C;/string>\n&#x3C;/resources>\n</code></pre>\n<p>Although there are many ways to implement the same thing, it seems quite\nreasonable to create an enum class for all the tags so that we can\neasily store the string resource identifiers with the translations\nthere.</p>\n<pre><code class=\"language-kotlin\">enum class PostTag(@StringRes val nameRes: Int) {\n    MUSIC(R.string.tag_music),\n    ART(R.string.tag_art)\n}\n</code></pre>\n<p>Each 9GAG post could be described with these tag enums like this:</p>\n<pre><code class=\"language-json\">{\n  \"content\": \"Lorem ipsum...\",\n  \"tags\": [\"MUSIC\", \"ART\"]\n}\n</code></pre>\n<p>The client app could parse these enums and show the appropriate\ntranslated tag names.</p>\n<pre><code class=\"language-kotlin\">val postTagsNames = post.tags.map {\n    context.getString(it.nameRes)\n}\n</code></pre>\n<h2>Forward incompatible enums</h2>\n<p>Let's assume we use\n<a href=\"https://github.com/Kotlin/kotlinx.serialization\">kotlinx.serialization</a>\nlibrary in the Android app to parse the JSON response bodies from the\nAPI. The default and simplest approach to enum serialization will\nprobably look like this:</p>\n<ul>\n<li>add <code>@Serializable</code> annotation to the <code>PostTag</code> enum class</li>\n<li>the library will use the\n<a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-enum/name.html\"><code>name</code> property</a>\nto serialize and deserialize enums</li>\n</ul>\n<p>Let's now imagine the backend developers extended the API by adding more\npost tags, e.g. a \"Books\" tag (encoded to string as <code>\"BOOKS\"</code>), while\nthe Android app haven't been updated yet. With the simple approach\nabove, the app will most probably fail to deserialize the new and\nunknown enum value <code>\"BOOKS\"</code> if a post contains one. In such case, we\nwill get the following exception:</p>\n<pre><code>kotlinx.serialization.SerializationException: com.example.9gag.posts.PostTag does not contain element with name 'BOOKS'\n</code></pre>\n<h3>Fallback enum value</h3>\n<p>While searching for a solution to this problem, we may find other people\nimplementing custom serializers with a dedicated \"fallback enum value\"\nlike in\n<a href=\"https://medium.com/livefront/kotlinx-serialization-json-deserializer-with-a-fallback-79dd6e9d471f\">this article</a>.\nThat approach requires us to add yet another enum value upfront and\nconfigure the serialization library to use <code>FALLBACK</code> value whenever it\ndeserializes an unexpected string in JSON.</p>\n<pre><code class=\"language-kotlin\">enum class PostTag(@StringRes val nameRes: Int) {\n    MUSIC(R.string.tag_music),\n    ART(R.string.tag_art),\n    FALLBACK(R.string.tag_fallback)\n}\n</code></pre>\n<p>As a result, the app will treat all the unknown enum values as the\nfallback value. I think it's better than nothing as it allows the app to\nhandle the unknown values somehow, e.g. by ignoring them, but it's not\nperfect either.</p>\n<p>First of all, if we want to just ignore the unknown values, it doesn't\nmake sense to create a dedicated string resource (like\n<code>R.string.tag_fallback</code>), but we have to do that because <code>nameRes</code>\nproperty is non-nullable. On the other hand, if we make it nullable to\nget rid of the unwanted resource, we will have to check the nullability\nevery time we process the post tags which is unnecessarily burdensome.</p>\n<p>There's another one, even more important downside of the fallback enum\nvalue approach. If our app caches the data from the API but we overwrite\nthe unknown values with said fallback value, we inevitably lose the\noriginal values the app received. If we later update the client app by\nadding the support for the <code>BOOKS</code> value, we will be forced to fetch the\ndata from the API again in order to restore the <code>BOOKS</code> tag value in the\npost.</p>\n<p>Of course, there are much more negative consequences possibly caused by\nlosing the original enum values, especially if we consider other types\nof apps and features, but let's focus on solving the problem first.</p>\n<h2>Forward compatibility of enums with <a href=\"https://github.com/bright/codified\">codified</a></h2>\n<p>We came up with a better solution over a year ago, and it has been\nworking really well since then. In short, instead of using a fallback\nenum values, we wrapped all the enums we send and receive from the APIs\nin a dedicated, generic sealed class allowing us to handle the unknown\nenum values very easily.</p>\n<p>With\n<a href=\"https://github.com/bright/codified\">codified library</a> we get the\nability to:</p>\n<ul>\n<li>serialize and deserialize both known and unknown enum values</li>\n<li>force the developers to handle both cases in\n<a href=\"https://kotlinlang.org/spec/expressions.html#exhaustive-when-expressions\">exhaustive <code>when</code> expressions</a></li>\n<li>preserve the unknown enum string codes (instead of overwriting them)</li>\n<li>use custom string codes (i.e. different than enum names) for each enum\nvalue</li>\n</ul>\n<p>In case of our exemplary <code>PostTag</code> enum class, all we need to do thanks\nto the\n<a href=\"https://github.com/bright/codified\">codified library</a> is:</p>\n<ul>\n<li>\n<p>implement <code>Codified&#x3C;String></code> interface in enum class</p>\n<pre><code class=\"language-kotlin\">enum class PostTag(\n  override val code: String, // allows using a custom string instead of enum's name\n  @StringRes val nameRes: Int\n) : Codified&#x3C;String> {\n  MUSIC(\"MUSIC\", R.string.tag_music),\n  ART(\"ART\", R.string.tag_art)\n}\n</code></pre>\n</li>\n<li>\n<p>declare the serializer object</p>\n<pre><code class=\"language-kotlin\">object PostTagCodifiedSerializer : KSerializer&#x3C;CodifiedEnum&#x3C;PostTag, String>> by codifiedEnumSerializer()\n</code></pre>\n</li>\n<li>\n<p>use the serializer wherever we want</p>\n<pre><code class=\"language-kotlin\">@Serializable\ndata class Post(\n  val content: String,\n  @Serializable(with = PostTagCodifiedSerializer::class)\n  val tags: List&#x3C;CodifiedEnum&#x3C;PostTag, String>>\n)\n</code></pre>\n</li>\n</ul>\n<p>When we deserialize the <code>Post</code> object from JSON and access the <code>tags</code>\nproperty, we can:</p>\n<ul>\n<li>\n<p>map all the known values to their translated names:</p>\n<pre><code class=\"language-kotlin\">val knownPostTagsNames = post.tags\n  .mapNotNull { it.knownOrNull() }\n  .map { context.getString(it.nameRes) }\n</code></pre>\n</li>\n<li>\n<p>check if the particular enum value is known or not and handle all the\npossible cases</p>\n<pre><code class=\"language-kotlin\">val tag: CodifiedEnum&#x3C;PostTag, String> // = ... get one from post.tags\nwhen (tag) {\n  is CodifiedEnum.Known -> when (tag.value) {\n      MUSIC -> TODO()\n      ART -> TODO()\n  }\n  is CodifiedEnum.Unknown -> TODO()\n}\n</code></pre>\n</li>\n<li>get the original string value: <code>tag.code()</code></li>\n</ul>\n<p>We can easily create the enum wrapper for any known <code>PostTag</code>:\n<code>PostTag.MUSIC.codifiedEnum()</code>.</p>\n<p>We can also create a wrapper for an unknown value and preserve the\nprovided string code: <code>\"BOOKS\".codifiedEnum&#x3C;PostTag>()</code></p>\n<h1>Conclusion</h1>\n<p>If you want to keep your API sane and create offline first applications,\nyou should consider the forward compatibility of your enums. Check out\n<a href=\"https://github.com/bright/codified\">codified</a> and give it a try - it\nwill make your life much easier.</p>\n<p><em>Note: codified version <code>1.1</code> uses <code>kotlinx.serialization</code> version\n<code>0.20.0</code>. Support for version <code>1.0.0</code> and later is coming soon.</em></p>\n<p><em>Image by <a href=\"https://pixabay.com/users/geralt-9301/\">Gerd\nAltmann</a> from <a href=\"https://pixabay.com/\">Pixabay</a></em></p>","excerpt":"A few years ago Adam outlined\n8 steps to keep your API sane\nin his blog post which I really recommend if you haven't seen it yet.\nThe second…","frontmatter":{"slug":null,"title":"Forward compatible enums in Kotlin","description":null,"author":"azabost","tags":["enum","kotlin","serialization","forward compatibility"],"date":"2020-11-17T18:49:00.000Z","image":"/images/forward-compatible-enums-in-kotlin/turn-on-2933016_1280.jpg"},"timeToRead":6,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-11-15-forward-compatible-enums-in-kotlin.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2020-11-15-forward-compatible-enums-in-kotlin.md"}}}