{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/multi-tenancy-task-scheduler","result":{"data":{"markdownRemark":{"html":"<p><a href=\"%7B%25%20post_url%202017-12-12-spring-mvc-multi-tenacy%20%25%7D\">Last time I showed</a> how to extend Spring default request handler adapter so that we are able to schedule or reject incoming requests. The goal of the <code>TenantTaskCoordinator</code> is to:</p>\n<ul>\n<li>queue requests for processing </li>\n<li>limit the maximum number of concurrently processed requests</li>\n<li>reject requests after the maximum queue size is reached</li>\n<li>interrupt processing of a request upon an upstream subscription disposal</li>\n</ul>\n<p><img src=\"/images/multi-tenancy-task-scheduler/sorting.jpg\" alt=\"Assigning resources\"></p>\n<h2>Tenant task coordinator execute method</h2>\n<p>Our entry point into <code>TenantTaskCoordinator</code> is a single method <code>fun &#x3C;T : Any> execute(job: Callable&#x3C;T>): Mono&#x3C;T></code>:</p>\n<pre><code class=\"language-kotlin\">    fun &#x3C;T : Any> execute(job: Callable&#x3C;T>): Mono&#x3C;T> {\n        return Mono.create({ outsideSink ->\n            val _workInProgressWasDecremented = AtomicBoolean(false)\n            fun decrementOnce() {\n                if (_workInProgressWasDecremented.compareAndSet(false, true)) {\n                    currentWorkInProgressCounter.decrementAndGet()\n                }\n            }\n\n            val workInProgress = currentWorkInProgressCounter.incrementAndGet()\n            if (workInProgress > maximumWorkInProgress) {\n                outsideSink.error(TooManyTasks(\"Work in progress $workInProgress exceeds $maximumWorkInProgress jobs in $name\"))\n                decrementOnce()\n            } else {\n                val singleJob = Mono.fromCallable(job).doAfterTerminate {\n                    decrementOnce()\n                }\n\n                val delayedTask = Task(name, singleJob as Mono&#x3C;Any>, outsideSink as MonoSink&#x3C;Any>)\n\n                outsideSink.onCancel {\n                    delayedTask.outsideCancel()\n                    decrementOnce()\n                }\n                \n                taskSink.next(delayedTask)\n            }\n        })\n    }\n</code></pre>\n<p>The first step is to return <code>Mono&#x3C;T></code> which is simply done with <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-\"><code>Mono.create</code></a>. The <code>sink</code> we get passed is used to control the outcome observed from outside. It also allows for registering an <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/MonoSink.html#onCancel-reactor.core.Disposable-\"><code>onCancel</code></a> callback invoked when the upstream cancels its subscription. </p>\n<p>The <code>_workInProgressWasDecremented</code> is used to guard and decrement the <code>currentWorkInProgressCounter</code> in a thread safe fashion. We first check whether we have immediately exceeded the maximum number of queued jobs. If the threshold is reached, we notify the observer about the error with <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/MonoSink.html#error-java.lang.Throwable-\"><code>outsideSink.error</code></a>. </p>\n<p>If we have enough capacity to a perform <code>job</code>, we convert it to a reactive world with <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-\"><code>Mono.fromCallable</code></a> and attach a <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-\"><code>doAfterTerminate</code></a> callback that decrements the work in progress counter. The <code>Task</code> class links <code>singleJob</code> and <code>outsideSink</code> so that they are both accessible while processing. Finally, we schedule the <code>task</code> through <code>taskSink.next(delayedTask)</code>.</p>\n<h2>Task coordinator state</h2>\n<p>Let's have a look at the task coordinator state variables and how they are initialized:</p>\n<pre><code class=\"language-kotlin\">class TenantTaskCoordinator(private val scheduler: Scheduler,\n                            val maximumConcurrency: Int = 1,\n                            val maximumQueueSize: Int = 50,\n                            val name: String = \"\") : AutoCloseable {\n\n    private val maximumWorkInProgress = maximumQueueSize + maximumConcurrency\n\n    private val maxBufferSize = maximumWorkInProgress * 2\n\n    val currentWorkInProgressCounter = AtomicInteger()\n\n    private lateinit var taskSink: FluxSink&#x3C;Task>\n\n    private val taskSource = Flux.create&#x3C;Task>({ taskSink = it }, FluxSink.OverflowStrategy.BUFFER)\n\n    private val processSinkOnErrorResume = processSinkWithLimitedConcurrency()\n        .onErrorResume { error: Throwable? ->\n            LOG.warn(\"name={} Error processing sink with limited concurrency\", name, error)\n            processSinkWithLimitedConcurrency()\n        }\n</code></pre>\n<p>The first interesting part is how we setup <code>taskSink</code> by using <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#create-java.util.function.Consumer-reactor.core.publisher.FluxSink.OverflowStrategy-\"><code>Flux.create</code></a>. For clarity, we explicitly pass <code>FluxSink.OverflowStrategy.BUFFER</code> so that tasks are buffered in case they outpace the processor. The <code>name</code> is used to get better log messages. Finally, we call <code>processSinkWithLimitedConcurrency</code> to start task processing using the given <code>scheduler</code>. Interestingly the <code>onErrorResume</code> restarts the processing in case we have a bug.</p>\n<h2>Task coordinator concurrent processing</h2>\n<p>The most important and tricky to figure out part is to correctly process jobs. It took me several back and forth steps until I got the order of reactive API calls right. </p>\n<pre><code class=\"language-kotlin\">    private fun processSinkWithLimitedConcurrency(): Flux&#x3C;Any> {\n        return taskSource\n            .filter { !it.isCancelled }\n            .flatMap({ task ->\n                task.work\n                    .doOnError(task::onError)\n                    .doOnSuccess(task::onSuccess)\n                    .subscribeOn(scheduler)\n                    .timeout(task.outsideTimeout)\n                    .onErrorReturn(task)\n            }, maximumConcurrency, maxBufferSize)\n    }\n</code></pre>\n<p>First, we filter out tasks that are already cancelled. Then, we use <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-int-int-\"><code>flatMap</code></a> overload to process tasks with given maximum concurrency. The <code>flatMap</code> callback delegates most of the work to the mentioned <code>Task</code> instance. The <code>onErrorReturn</code> effectively suppresses any errors that might occur during <code>task</code> execution. Let's see how the inner <code>Task</code> class looks like:</p>\n<pre><code class=\"language-kotlin\">private data class Task(val name: String,\n                            private val job: Mono&#x3C;Any>,\n                            val outsideSink: MonoSink&#x3C;Any>,\n                            @field:Volatile var isCancelled: Boolean = false) {\n\n        val work: Mono&#x3C;Any> get() = if (isCancelled) Mono.empty() else job\n\n        lateinit var outsideTimeoutSink: MonoSink&#x3C;Task>\n        val outsideTimeout = Mono.create&#x3C;Task> { outsideTimeoutSink = it }\n\n        fun outsideCancel() {\n            isCancelled = true\n            outsideTimeoutSink.success(this)\n        }\n\n        fun onSuccess(result: Any?) {\n            outsideSink.success(result)\n        }\n        \n        fun onError(error: Throwable) {\n            LOG.warn(\"Task.onError {}\", this, error)\n            outsideSink.error(error)\n        }\n    }\n</code></pre>\n<p>The <code>job</code> argument is the <code>Callable</code> passed to the <code>execute</code> method. The <code>outsideTimeout</code> signals when the <code>task</code> instance subscription is cancelled. The signal is propagated inside <code>processSinkWithLimitedConcurrency</code> with a <a href=\"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-org.reactivestreams.Publisher-\"><code>Mono.timeout</code></a> call and breaks the <code>task</code> processing. Last but not least the <code>onSuccess</code> and <code>onError</code> simply push the result or error to the <code>outsideSink</code> effectively notifying the observer of the result. </p>\n<p>The <a href=\"https://gist.github.com/miensol/1e2b203a128cdc428f3b0c598e515bd6\"><code>TenantTaskCoordinator</code></a> was not simple to figure out given the requirements mentioned at the begging of the post. I'm pleased with the final result although I must say it was not intuitive to figure out how to combine all the nuts and bolts of <a href=\"https://projectreactor.io/\">Reactor</a> library to achieve the desired outcome.</p>","excerpt":"Last time I showed how to extend Spring default request handler adapter so that we are able to schedule or reject incoming requests. The…","frontmatter":{"slug":null,"title":"Multi tenancy task scheduler","description":null,"author":"piotr","tags":["spring","mvc","spring-boot","multi-tenant","reactive","reactor"],"date":"2018-01-03T23:00:00.000Z","image":"/images/multi-tenancy-task-scheduler/sorting.jpg"},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-04-multi-tenancy-task-scheduler.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-01-04-multi-tenancy-task-scheduler.md"}}}