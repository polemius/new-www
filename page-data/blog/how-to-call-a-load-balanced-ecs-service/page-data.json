{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/how-to-call-a-load-balanced-ecs-service","result":{"data":{"markdownRemark":{"html":"<p>A service running <a href=\"https://aws.amazon.com/ecs/\">ECS</a> can call plethora of AWS APIs. It can read messages from queues, publish messages to <a href=\"https://aws.amazon.com/sns/\">SNS</a> topics, query a database. These are all valid ways to communicate with the service. However, often the most appropriate way is to call the service by an HTTP API. In this post I'll describe how to configure an ECS service running inside VPC so that other services can call its API.</p>\n<p><img src=\"/images/ecs-service/containers.jpeg\" alt=\"containers\"></p>\n<h1>Deploy an ECS service to multiple hosts</h1>\n<p>Whenever we care about availability of a service running inside AWS, we need to have it running in at least 2 availability zones. For that reason when defining the ECS Cluster Auto Scaling Group we need to specify at least 2 VPC Subnets running in different availability zones.</p>\n<pre><code class=\"language-json\">\"ECSMainCluster\": {\n    \"Type\": \"AWS::ECS::Cluster\",\n    \"Properties\": { \"ClusterName\": \"Main Cluster\" }\n},\n\"ECSAutoScalingGroup\": {\n    \"Type\": \"AWS::AutoScaling::AutoScalingGroup\",\n    \"Properties\": {\n        \"VPCZoneIdentifier\": [\n            { \"Ref\": \"PrivateASubnet\" },\n            { \"Ref\": \"PrivateBSubnet\" }\n        ],\n        \"LaunchConfigurationName\": { \"Ref\": \"ContainerHostInstances\" },\n        \"MinSize\": \"2\",\n        \"MaxSize\": \"6\",\n        \"DesiredCapacity\": \"2\"                \n    }\n},\n\"ServiceA\": {\n    \"Type\": \"AWS::ECS::Service\",\n    \"Properties\": {\n        \"Cluster\": { \"Ref\": \"ECSMainCluster\" },\n        \"DesiredCount\": 2,\n        \"LoadBalancers\": [{\n            \"ContainerName\": \"serviceA\",\n            \"ContainerPort\": 8080,\n            \"TargetGroupArn\": { \"Ref\": \"ServiceAAlbTargetGroup\" }\n        }],\n        \"DeploymentConfiguration\": { \"MinimumHealthyPercent\": 50 },\n        \"Role\": { \"Ref\": \"ECSServiceRole\" },\n        \"TaskDefinition\": { \"Ref\": \"ServiceATask\" }\n    }\n}\n</code></pre>\n<p>Notice how we are using 2 private subnets as <code>VPCZoneIdentifier</code>. The <code>MinSize</code> is also set to 2 which will cause both availability zones to have at least 1 instance running. For brevity subnets and VPC definitions are not included. You can find more details about how to configure the EC2 instances inside ECS cluster <a href=\"%7B%25%20post_url%202018-02-19-how-to-deploy-a-service-to-amazon-elastic-container-service-with-cloud-formation%20%25%7D\">in my previous post</a>.</p>\n<p>The <code>ServiceA</code> deployed in <code>ECSMainCluster</code> is also specifying that at it has <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html\"><code>DesiredCount</code></a> of 2 which instructs ECS to have at least 2 instances of the service running. The <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html#cfn-ecs-service-loadbalancers\"><code>LoadBalancers</code></a> and <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html#cfn-ecs-service-role\"><code>Role</code></a> attributes are required for the load balanced setup. The <code>ECSServiceRole</code> must allow the ECS agent to make calls to the load balancer API. The <code>LoadBalancers</code> reference <a href=\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html\">an ALB target group</a> to which the running ECS task should be added.</p>\n<h1>A private load balancer</h1>\n<p>In order for us to be able to call an API exposed by ECS service running on multiple instances we will use <a href=\"https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html\">an internal Application Load Balancer</a>. By internal, I mean that the load balancer will not be accessible outside of the VPC.</p>\n<pre><code class=\"language-json\">\"PrivateApiLoadBalancer\": {\n    \"Type\": \"AWS::ElasticLoadBalancingV2::LoadBalancer\",\n    \"Properties\": {\n        \"Subnets\": [\n            { \"Ref\": \"PrivateASubnet\" },\n            { \"Ref\": \"PrivateBSubnet\" }\n        ],\n        \"Name\": \"PrivateApiLoadBalancer\",\n        \"Scheme\": \"internal\",\n        \"SecurityGroups\": [{\n            \"Ref\": \"HttpHttpsProxySecurityGroup\"\n        }]\n    }\n},\n\"HttpHttpsProxySecurityGroup\": {\n    \"Type\": \"AWS::EC2::SecurityGroup\",\n    \"Properties\": {\n        \"GroupDescription\": \"Enable http and https access\",\n        \"VpcId\": { \"Ref\": \"VPC\" },\n        \"SecurityGroupIngress\": [{\n            \"IpProtocol\": \"tcp\", \"FromPort\": \"80\", \"ToPort\": \"80\",\n            \"CidrIp\": { \"Ref\": \"VPCCidr\" }\n        }, {\n            \"IpProtocol\": \"tcp\", \"FromPort\": \"443\", \"ToPort\": \"443\",\n            \"CidrIp\": { \"Ref\": \"VPCCidr\" }\n        }],\n        \"SecurityGroupEgress\": [{\n            \"IpProtocol\": \"-1\",\n            \"CidrIp\": { \"Ref\": \"VPCCidr\" }\n        }]\n    }\n}\n</code></pre>\n<p>There are only 2 important aspects to the <code>PrivateApiLoadBalancer</code>. First, it is attached to the same subnets as our ECS task definition. Secondly, it has a security group configured which allows for incoming HTTP/HTTPS traffic and outgoing traffic to any IP in the VPC CIDR address. The egress rule is required for the load balancer to be able to check the health of its targets.</p>\n<p>For the load balancer to perform some actions we need to configure listeners that define its behavior in response to incoming traffic.</p>\n<pre><code class=\"language-json\">\"PrivateApiLoadBalancerHttpListener\": {\n    \"Type\": \"AWS::ElasticLoadBalancingV2::Listener\",\n    \"Properties\": {\n        \"Port\": 80,\n        \"Protocol\": \"HTTP\",\n        \"LoadBalancerArn\": { \"Ref\": \"PrivateApiLoadBalancer\" },\n        \"DefaultActions\": [{\n            \"Type\": \"forward\",\n            \"TargetGroupArn\": {\n                \"Ref\": \"PrivateApiLoadBalancerInvalidHostGroup\"\n            }\n        }]\n    }\n},\n\"PrivateApiLoadBalancerInvalidHostGroup\": {\n    \"Type\": \"AWS::ElasticLoadBalancingV2::TargetGroup\",\n    \"Properties\": {\n        \"Protocol\": \"HTTP\",\n        \"Port\": 80,\n        \"VpcId\": { \"Ref\": \"VPC\" },\n        \"Name\": \"invalid-target-group\"\n    }\n}\n</code></pre>\n<p>The <code>PrivateApiLoadBalancerHttpListener</code> specifies that the HTTP request to <code>PrivateApiLoadBalancer</code> on port 80 should be routed to <code>PrivateApiLoadBalancerInvalidHostGroup</code>. The <code>AWS::ElasticLoadBalancingV2::Listener</code> requires us to set the <code>DefaultActions</code>. The above setup allows us to fail in a consistent manner. Unless there are <code>AWS::ElasticLoadBalancingV2::ListenerRule</code> which match an incoming the HTTP request it will be routed to an empty <code>AWS::ElasticLoadBalancingV2::TargetGroup</code> which in turn will result in 502 Bad Gateway. This allows us to effectively decouple the <code>DefaultActions</code> of the load balancer listener from a specific ECS service instance.</p>\n<h1>Attach ECS service to an Application Load Balancer</h1>\n<p>It is time to route a request from the Application Load Balancer to the ECS service instances. The <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listenerrule.html\"><code>AWS::ElasticLoadBalancingV2::ListenerRule</code></a> allows us to configure such behavior:</p>\n<pre><code class=\"language-json\">\"ServiceAAlbHttpListenerRule\": {\n    \"Type\": \"AWS::ElasticLoadBalancingV2::ListenerRule\",\n    \"Properties\": {\n        \"Actions\": [{\n            \"Type\": \"forward\",\n            \"TargetGroupArn\": { \"Ref\": \"ServiceAAlbTargetGroup\" }\n        }],\n        \"Priority\": 1,\n        \"Conditions\": [{\n            \"Field\": \"host-header\",\n            \"Values\": [ \"service-a.in.example.com\"]\n        }],\n        \"ListenerArn\": {\n            \"Ref\": \"PrivateApiLoadBalancerHttpListener\"\n        }\n    }\n},\n\"ServiceAAlbTargetGroup\": {\n    \"Type\": \"AWS::ElasticLoadBalancingV2::TargetGroup\",\n    \"Properties\": {\n        \"Protocol\": \"HTTP\",\n        \"Port\": 8080,\n        \"HealthCheckPath\": \"/application-status/health\",\n        \"HealthyThresholdCount\": 2,\n        \"UnhealthyThresholdCount\": 10,\n        \"HealthCheckIntervalSeconds\": 5,\n        \"HealthCheckTimeoutSeconds\": 4,\n        \"VpcId\": { \"Ref\": \"VPC\" },\n        \"Name\": \"service-a-target-group\"\n    }\n}\n</code></pre>\n<p>The <code>ServiceAAlbHttpListenerRule</code> states that any request with a <code>Host</code> equal to <code>service-a.in.example.com</code> should be routed to an instance from the <code>ServiceAAlbTargetGroup</code>. The <code>ServiceAAlbTargetGroup</code> group is referenced from the <code>ServiceA</code> definition and contains all running and healthy instances of our task. This means that in order to call the HTTP API exposed by <code>ServiceA</code> we will simply use the <code>service-a.in.example.com</code> domain name.</p>\n<h1>A private DNS record</h1>\n<p>The last part is to define a <a href=\"https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/hosted-zone-private-creating.html\">Private Hosted Zone</a> and <a href=\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-route53-recordset.html\">a DNS Record Set</a> so that a DNS look up, happening inside the VPC, for <code>service-a.in.example.com</code> results in an IP address of the <code>PrivateApiLoadBalancer</code>.</p>\n<pre><code class=\"language-json\">\"PrivateHostedZone\": {\n    \"Type\": \"AWS::Route53::HostedZone\",\n    \"Properties\": {\n        \"VPCs\": [{\n            \"VPCId\": { \"Ref\": \"VPC\" },\n            \"VPCRegion\": { \"Ref\": \"AWS::Region\" }\n        }],\n        \"Name\": \"in.example.com\"\n    }\n},\n \"ServiceALoadBalancerDNSRecord\": {\n    \"Type\": \"AWS::Route53::RecordSet\",\n    \"Properties\": {\n        \"Name\": \"service-a.in.example.com\",\n        \"HostedZoneId\": { \"Ref\": \"PrivateHostedZone\" },\n        \"ResourceRecords\": [{\n            \"Fn::GetAtt\": [\"PrivateApiLoadBalancer\", \"DNSName\"]\n        }],\n        \"TTL\": 60,\n        \"Type\": \"CNAME\"\n    }\n}\n</code></pre>\n<p>The <code>PrivateHostedZone</code> merely defines the name of the domain which we will use for addressing ECS services running inside our VPC. It is recommended to use a domain name that you control so that a mistake in the DNS configuration will not cause your services to call an address that you do not own. The <code>ServiceALoadBalancerDNSRecord</code> defines a CNAME that uses <code>PrivateApiLoadBalancer</code> AWS assigned DNS name. This way the lookup for <code>service-a.in.example.com</code> will effectively resolve to multiple IPs in different availability zones.</p>\n<p>With the above configuration in place we can call an HTTP API exposed privately by a load balanced service running inside VPC on ECS cluster using the most natural way i.e. a DNS name.</p>","excerpt":"A service running ECS can call plethora of AWS APIs. It can read messages from queues, publish messages to SNS topics, query a database…","frontmatter":{"slug":null,"title":"How to call a load balanced ECS service?","description":null,"author":"piotr","tags":["aws","ecs","cloudformation","elb","cloudform"],"date":"2018-03-05T23:00:00.000Z","image":"/images/ecs-service/containers.jpeg"},"timeToRead":6,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-03-06-how-to-call-a-load-balanced-ecs-service.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2018-03-06-how-to-call-a-load-balanced-ecs-service.md"}}}