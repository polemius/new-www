{"componentChunkName":"component---src-templates-post-template-tsx","path":"/blog/reactiveswift-manage-your-memory","result":{"data":{"markdownRemark":{"html":"<p>Memory management is a pretty important issue when talking about any kind of system. You can't pretend that your resources are unlimited, and give them out no matter what. When working with <code>ReactiveSwift</code> it's really easy to fall into the pit of wasted resources if you don't follow simple rules.</p>\n<h2>Disposables</h2>\n<p>Basic unit that will help us handle our memory management, when working with <code>ReactiveSwift</code> is <code>disposable</code>. At the same time that you start observing <code>Signal</code>, or start any work with <code>Signal Producer</code>, you will gain access to such <code>Disposable</code>. If you are not interested in results that come through that <code>Signal</code>, you can simply call <code>.dispose()</code> method on that <code>disposable</code>, and you won't receive updates any more. This also means, that as soon as <code>SignalProducer</code> notices, that nobody is interested in it's results, it can stop it's work and clean resources.</p>\n<p>It's common to free any resources when you exit a screen in your application. This means, that you should dispose all your <code>disposables</code> as well. Of course it would be hard to store each <code>disposable</code> in separate variable and dispose when you're not interested in updates anymore. That's why we can use a container for such <code>disposables</code> - <code>CompositeDisposable</code>. You can basically throw any <code>disposable</code> inside this container, and dispose all of them at once when your view controller deinitializes.</p>\n<p>Let's take a look at how to work with disposables.</p>\n<pre><code class=\"language-swift\">// public variable accessible from outside of class\nvar producer: SignalProducer&#x3C;String, NoError>\n\ninit() {  \n  producer = SignalProducer {[weak self] observer, compositeDisposable in\n      guard let strongSelf = self else { return }\n      compositeDisposable.add {\n          print(\"I've been disposed! I can clean my resources ;)\")\n      }\n\n      DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: {\n          if !compositeDisposable.isDisposed {\n              strongSelf.performHeavyCalculation()\n              observer.send(value: \"1\")\n          }\n      })\n      DispatchQueue.main.asyncAfter(deadline: .now() + 3, execute: {\n          if !compositeDisposable.isDisposed {\n              strongSelf.performHeavyCalculation()\n              observer.send(value: \"2\")\n          }\n      })\n  }\n\n  // If you have compositeDisposables variable, then you can add it there\n  // disposables += producer.startWithValues ...\n\n  // You keep received disposable in variable\n  let disposable = producer.startWithValues {[unowned self] (value) in\n      print(value)\n      self.performHeavyCalculation()\n  }\n\n  DispatchQueue.main.asyncAfter(deadline: .now() + 2) {\n      disposable.dispose() // After some time, you are not interested in producer's work, and you kindly tell him that\n  }\n}\n</code></pre>\n<p>What will happen here?\nProducer does not start it's work until <code>startWithValues</code> is called. After that, we have to actions scheduled that will send us values <code>1</code> and <code>2</code>. They will also perform some heavy calculations. After two seconds, I decide that I'm not interested in any results, so I dispose received <code>disposable</code> and I will not receive any updates in <code>startWithValues</code> block anymore. However, work in producer has been already scheduled. That's why I put the <code>if</code> statement checking if someone is still interested in producer's work. If not, I will not perform that.</p>\n<pre><code class=\"language-swift\">var disposables = CompositeDisposable()\n\ndisposables += viewModel.criticalInfo.observeValues {[unowned self] (value) in\n// react to value\n}\n\ndeinit {\n  disposables.dispose()\n}\n</code></pre>\n<p>In this example, Let's imagine that you create your <code>disposables</code> variable at the time you initialize your class. Then, when you start observing any signals, you add each <code>disposable</code> to your container. You can dispose them any time you want, but most often, you will do it at the time that you dealloc your controller, so you can add this code to <code>deinit</code>.</p>\n<p>You may have noticed, that there are parts where are use <code>[weak self]</code> and <code>[unowned self]</code>. Let's take a closer look at this!</p>\n<h2>Working with closures</h2>\n<p>Disposables are one important thing that will lead you to memory management heaven. Next things that you have to remember about when working with ReactiveSwift is to manage relationships in closures that you pass to observers. When you do anything with a <code>self</code> variable in such closure, you create a retain cycle, as you hold strong reference to <code>self</code>. Controller holds a closure and closure holds controller. No way that they will be released any time soon. To have a weak reference to <code>self</code>, you can add <code>[weak self]</code> or <code>[unowned self]</code> to such closure. If you do not add one of those statements, your <code>disposables.dispose()</code> in <code>deinit</code> method will not be even reached, as controller will not be deinitialized.</p>\n<pre><code class=\"language-swift\">// weak reference, but we bet that self will not be nil\ndisposables += signal.observe {[unowned self] values in\n  self.workWithMeAllTheTime()\n}\n\n// weak reference, but self becomes optional\ndisposables += signal.observe {[weak self] values in\n  guard let strongSelf = self else { return }\n  strongSelf.workWithMeAllTheTime()\n}\n\n...\n\ndeinit {\n  disposable.dispose()\n}\n</code></pre>\n<p>What is the difference between <code>[weak self]</code> and <code>[unowned self]</code> you ask?\nWhen you use <code>[weak self]</code>, you tell your closure, that it is possible that <code>self</code> could be <code>nil</code> at some point. I usually put a <code>guard let</code> statement at the beginning of this kind of closure, so if <code>self</code> is nil, I don't continue with any operations.\nOn the other hand, we have <code>[unowned self]</code> that doesn't tell us that <code>self</code> could be <code>nil</code> at some point. It's on our side to take care of that and make sure that this block will not be called if <code>self</code> is deinitialized. If you properly take care of <code>disposables</code>, most often <code>[unowned self]</code> is a safe bet, as those closures will not be executed after deinitialization of <code>self</code>.</p>\n<h2>A note to first example</h2>\n<p>Let's get back to the code from first example. You can see, that I used a <code>[weak self]</code> for the <code>SignalProducer</code> and <code>[unowned self]</code> for the observer. Why did I do that?!\nWhen I start observing for values from producer in <code>startWithValues</code> closure, I'm pretty sure that I'll call <code>dispose</code> when my controller deinits, so I know that <code>self</code> will be there if I need it. With given <code>SignalProducer</code> that's a bit different. It is accessible from outside. Let's imagine, that I've saved this producer at the time that this class was alive, and started it's work after it was deinitialized. If I had <code>[unowned self]</code> there, then it would cause a crash. As long as I have <code>[weak self]</code>, at the beginning of my producer's work I can check if <code>self</code> exists and If it doesn't I can discontinue with any other work. If it does, I'll create a reference to <code>self</code> and proceed with my work.</p>\n<p>There are always edge cases, that may cause a headache when choosing between <code>unowned</code> and <code>weak</code>, but as the time goes, you'll find it easier and easier to work with them! See you next time!</p>\n<p><em>This article is cross-posted with my <a href=\"https://eliaszsawicki.com/\">my personal blog</a>.</em></p>","excerpt":"Memory management is a pretty important issue when talking about any kind of system. You can't pretend that your resources are unlimited…","frontmatter":{"slug":null,"title":"ReactiveSwift - Manage your memory!","description":null,"author":"eliasz","tags":["iOS"],"date":"2016-10-21T22:00:00.000Z","image":null},"timeToRead":5,"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2016-10-22-reactiveswift-manage-your-memory.md"},"allMarkdownRemark":{"nodes":[{"frontmatter":{"author_id":"adam","avatar":"/images/members/adam_bar.jpg","bio":"The Web Guy @ Bright Inventions","name":"Adam Bar","web":"https://whatwebcando.today"}},{"frontmatter":{"author_id":"agnieszka_h","avatar":"/images/members/agnieszka_h.jpg","bio":"Sales Manager @ Bright Inventions","name":"Agnieszka Hayashida","web":null}},{"frontmatter":{"author_id":"agnieszka","avatar":"/images/members/agnieszka_olszewska.jpg","bio":"Fullstack developer","name":"Agnieszka Olszewska","web":null}},{"frontmatter":{"author_id":"olo","avatar":"/images/members/aleksander_wielgorski.jpeg","bio":"Software Engineer @ Bright Inventions","name":"Aleksander Wielgórski","web":null}},{"frontmatter":{"author_id":"alisa","avatar":"/images/members/alisa_kashytska.jpg","bio":"Product designer","name":"Alisa Kashytska","web":null}},{"frontmatter":{"author_id":"azabost","avatar":"/images/members/andrzej_zabost.jpg","bio":"Senior Android developer","name":"Andrzej Zabost","web":"https://azabost.com"}},{"frontmatter":{"author_id":"arturs","avatar":"/images/members/artur.jpg","bio":"iOS developer","name":"Artur Suliński","web":null}},{"frontmatter":{"author_id":"bartek k","avatar":"/images/members/bartek_krzyzanski.jpg","bio":"Backend developer","name":"Bartek Krzyżański","web":null}},{"frontmatter":{"author_id":"bartekr","avatar":"/images/members/bartek.jpg","bio":"iOS developer","name":"Bartek Rozwarski","web":null}},{"frontmatter":{"author_id":"bartosz","avatar":"/images/members/bartosz_szafran.jpg","bio":"Senior Frontend Developer","name":"Bartosz Szafran","web":null}},{"frontmatter":{"author_id":"daniel","avatar":"/images/members/daniel_makurat.jpg","bio":"Co-founder & Senior Backend developer","name":"Daniel Makurat","web":null}},{"frontmatter":{"author_id":"eliasz","avatar":"/images/members/eliasz.png","bio":"Software Engineer @ Bright Inventions","name":"Eliasz Sawicki","web":"http://eluss.github.io/"}},{"frontmatter":{"author_id":"fjablonski","avatar":"/images/members/filip_jablonski.jpg","bio":"Senior iOS developer","name":"Filip Jabłoński","web":null}},{"frontmatter":{"author_id":"grzesiek","avatar":"/images/members/grzegorz_ciesla.jpg","bio":"Software Developer","name":"Grzegorz Cieśla","web":null}},{"frontmatter":{"author_id":"ivan","avatar":"/images/members/ivan.jpg","bio":"Fullstack developer","name":"Ivan Menshykov","web":null}},{"frontmatter":{"author_id":"janek","avatar":"/images/members/janhanc.jpg","bio":"Frontend developer","name":"Jan Hanc","web":null}},{"frontmatter":{"author_id":"kwysocki","avatar":"/images/members/kamil.png","bio":"Software Engineer @ Bright Inventions","name":"Kamil Wysocki","web":"https://wysockikamil.com"}},{"frontmatter":{"author_id":"karoln","avatar":"/images/members/karol_nadratowski.jpg","bio":null,"name":"Karol Nadratowski","web":null}},{"frontmatter":{"author_id":"karol r","avatar":"/images/members/karol_rinc.jpg","bio":"Backend developer","name":"Karol Rinc","web":null}},{"frontmatter":{"author_id":"kasia","avatar":"/images/members/kasia_lukasiewicz.jpg","bio":"Senior Project Manager","name":"Kasia Łukasiewicz","web":null}},{"frontmatter":{"author_id":"kasia g","avatar":"/images/members/katarzyna_galka.jpg","bio":"Project manager","name":"Katarzyna Gałka","web":null}},{"frontmatter":{"author_id":"krzysiek h","avatar":"/images/members/krzysztof_hinc.jpg","bio":"Web developer","name":"Krzysiek Hinc","web":null}},{"frontmatter":{"author_id":"krzysiek","avatar":"/images/members/krzysztof_kaczmarek.jpg","bio":"Senior iOS Developer","name":"Krzysztof Kaczmarek","web":null}},{"frontmatter":{"author_id":"maciej","avatar":"/images/members/maciej_seleman.jpg","bio":"QA Specialist","name":"Maciej Seleman","web":null}},{"frontmatter":{"author_id":"magda","avatar":"/images/members/magda_sadowska.jpg","bio":"Office & HR Assistant","name":"Magda Sadowska","web":null}},{"frontmatter":{"author_id":"maja","avatar":"/images/members/maja_puta.jpg","bio":"Junior QA Specialist","name":"Maja Puta","web":null}},{"frontmatter":{"author_id":"marcink","avatar":"/images/members/marcin_kwiatkowski.jpg","bio":null,"name":"Marcin Kwiatkowski","web":null}},{"frontmatter":{"author_id":"mateusz","avatar":"/images/members/mateusz_klimczak.jpg","bio":"Technical leader & Project manager","name":"Mateusz Klimczak","web":null}},{"frontmatter":{"author_id":"mateuszklimek","avatar":"/images/members/mateuszklimek.png","bio":"Software Engineer @ Bright Inventions","name":"Mateusz Klimek","web":null}},{"frontmatter":{"author_id":"michal k","avatar":"/images/members/michal_koszalka.jpg","bio":"Senior Backend developer","name":"Michał Koszałka","web":null}},{"frontmatter":{"author_id":"michał","avatar":"/images/members/michal_wrobel.jpg","bio":"Senior Backend Developer at Bright Inventions","name":"Michał Wróbel","web":null}},{"frontmatter":{"author_id":"michal","avatar":"/images/members/michał_łukasiewicz.jpg","bio":"Co-founder & Senior iOS developer","name":"Michał Łukasiewicz","web":null}},{"frontmatter":{"author_id":"monika","avatar":"/images/members/monika.jpg","bio":"Software Developer @ Bright Inventions","name":"Monika Niegrzybowska","web":null}},{"frontmatter":{"author_id":"nikodem","avatar":"/images/members/nikodem_kalinowski.jpg","bio":"Web developer","name":"Nikodem Kalinowski","web":null}},{"frontmatter":{"author_id":"patryk","avatar":"/images/members/patryk_huzarski.jpg","bio":"Software Developer @ Bright Inventions","name":"Patryk Huzarski","web":null}},{"frontmatter":{"author_id":"patryk sz","avatar":"/images/members/patryk_szlagowski.jpg","bio":"Senior Backend developer","name":"Patryk Szlagowski","web":null}},{"frontmatter":{"author_id":"paweł","avatar":"/images/members/paweł_gutkowski.jpg","bio":"Fullstack Developer at Bright Inventions ","name":"Paweł Gutkowski","web":null}},{"frontmatter":{"author_id":"pawel","avatar":"/images/members/paweł_papkiewicz.jpg","bio":"Fullstack developer","name":"Paweł Papkiewicz","web":null}},{"frontmatter":{"author_id":"piotr","avatar":"/images/members/piotr_mionskowski.jpg","bio":"TDD fan eager to learn new things","name":"Piotr Mionskowski","web":"https://miensol.pl"}},{"frontmatter":{"author_id":"piotr_l","avatar":"/images/members/piotrl.png","bio":"Android Developer @ Bright Inventions","name":"Piotr Łupiński","web":"http://exp.flamaster2.com"}},{"frontmatter":{"author_id":"radek","avatar":"/images/members/radek_pieczątkiewicz.jpg","bio":"Android developer","name":"Radek Pieczątkiewicz","web":null}},{"frontmatter":{"author_id":"radeks","avatar":"/images/members/radoslaw.jpg","bio":"Software Engineer @ Bright Inventions","name":"Radosław Słowiński","web":null}},{"frontmatter":{"author_id":"rafal h","avatar":"/images/members/rafal_hoffman.jpg","bio":"Fullstack developer","name":"Rafał Hofman","web":null}},{"frontmatter":{"author_id":"sebastian","avatar":"/images/members/sebastian_sobczak.jpg","bio":"Junior Account Manager at Bright Inventions ","name":"Sebastian Sobczak","web":null}},{"frontmatter":{"author_id":"szymek","avatar":"/images/members/szymon_miloch.jpg","bio":"Android & Web developer","name":"Szymon Miloch","web":null}},{"frontmatter":{"author_id":"tomek","avatar":"/images/members/tomek.jpeg","bio":null,"name":"Tomasz Gęsior","web":null}},{"frontmatter":{"author_id":"ula","avatar":"/images/members/ula_stankiewicz.jpg","bio":"HR & Marketing Manager","name":"Ula Stankiewicz","web":null}},{"frontmatter":{"author_id":"wojciech","avatar":"/images/members/wojciech_baczyński.jpg","bio":"Fullstack developer","name":"Wojciech Baczyński","web":null}},{"frontmatter":{"author_id":"lukasz","avatar":"/images/members/lukasz_reszetow.jpg","bio":"Android developer","name":"Łukasz Reszetow","web":null}}]},"site":{"siteMetadata":{"siteUrl":"https://brightinventions.pl"}}},"pageContext":{"fileAbsolutePath":"/home/runner/work/new-www/new-www/src/mdData/blog/2016-10-22-reactiveswift-manage-your-memory.md"}}}